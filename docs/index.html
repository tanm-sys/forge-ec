<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Forge EC Documentation - Complete API reference and guides">
    <title>Documentation - Forge EC</title>
    <!-- Cache busting comment: Updated to fix loading issue -->

    <link rel="icon" type="image/x-icon" href="../assets/favicon.ico">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/loading.css">
    <link rel="stylesheet" href="../css/prism.css">
    <link rel="stylesheet" href="../css/docs.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Loading Progress Bar -->
    <div class="loading-progress" id="loading-progress"></div>

    <!-- Page Loader -->
    <div class="page-loader" id="page-loader">
        <div>
            <div class="loader-spinner"></div>
            <div class="loader-text">Loading Documentation...</div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="navbar" id="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <img src="../assets/logo.svg" alt="Forge EC" class="nav-logo">
                <a href="../index.html" class="nav-title">Forge EC</a>
            </div>

            <div class="nav-menu" id="nav-menu">
                <a href="../index.html" class="nav-link">Home</a>
                <a href="index.html" class="nav-link active">Documentation</a>
                <a href="../examples/" class="nav-link">Examples</a>
                <a href="../about/" class="nav-link">About</a>
                <a href="https://github.com/tanm-sys/forge-ec" class="nav-link" target="_blank">GitHub</a>
            </div>

            <div class="nav-controls">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon">üåô</span>
                </button>
                <button class="nav-toggle" id="nav-toggle" aria-label="Toggle navigation">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
        </div>
    </nav>

    <div class="docs-layout">
        <!-- Sidebar -->
        <aside class="docs-sidebar" id="docs-sidebar">
            <div class="sidebar-content">
                <div class="search-box">
                    <input type="text" id="search-input" placeholder="Search documentation..." class="search-input">
                    <div class="search-results" id="search-results"></div>
                </div>

                <nav class="sidebar-nav">
                    <div class="nav-section">
                        <h3 class="nav-section-title">Getting Started</h3>
                        <ul class="nav-list">
                            <li><a href="#overview" class="nav-item active">Overview</a></li>
                            <li><a href="#installation" class="nav-item">Installation</a></li>
                            <li><a href="#quick-start" class="nav-item">Quick Start</a></li>
                            <li><a href="#architecture" class="nav-item">Architecture</a></li>
                        </ul>
                    </div>

                    <div class="nav-section">
                        <h3 class="nav-section-title">API Reference</h3>
                        <ul class="nav-list">
                            <li><a href="#core-traits" class="nav-item">Core Traits</a></li>
                            <li><a href="#curves" class="nav-item">Curves</a></li>
                            <li><a href="#signatures" class="nav-item">Signatures</a></li>
                            <li><a href="#encoding" class="nav-item">Encoding</a></li>
                            <li><a href="#hashing" class="nav-item">Hashing</a></li>
                            <li><a href="#rng" class="nav-item">Random Number Generation</a></li>
                        </ul>
                    </div>

                    <div class="nav-section">
                        <h3 class="nav-section-title">Guides</h3>
                        <ul class="nav-list">
                            <li><a href="#security" class="nav-item">Security Considerations</a></li>
                            <li><a href="#performance" class="nav-item">Performance Guide</a></li>
                            <li><a href="#interop" class="nav-item">Interoperability</a></li>
                            <li><a href="#testing" class="nav-item">Testing</a></li>
                        </ul>
                    </div>

                    <div class="nav-section">
                        <h3 class="nav-section-title">Examples</h3>
                        <ul class="nav-list">
                            <li><a href="#ecdsa-example" class="nav-item">ECDSA Signatures</a></li>
                            <li><a href="#eddsa-example" class="nav-item">EdDSA Signatures</a></li>
                            <li><a href="#ecdh-example" class="nav-item">ECDH Key Exchange</a></li>
                            <li><a href="#schnorr-example" class="nav-item">Schnorr Signatures</a></li>
                        </ul>
                    </div>
                </nav>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="docs-main">
            <div class="docs-content">
                <!-- Overview Section -->
                <section id="overview" class="docs-section">
                    <h1 class="docs-title">Forge EC Documentation</h1>
                    <p class="docs-subtitle">
                        Complete guide to using Forge EC, a comprehensive elliptic curve cryptography library in pure Rust.
                    </p>

                    <div class="feature-grid">
                        <div class="feature-card animate-on-scroll hover-lift magnetic-hover">
                            <div class="feature-icon animate-float">üîí</div>
                            <h3>Security First</h3>
                            <p>Constant-time operations and zero unsafe code in public API</p>
                        </div>
                        <div class="feature-card animate-on-scroll hover-lift magnetic-hover">
                            <div class="feature-icon animate-float stagger-1">‚ö°</div>
                            <h3>High Performance</h3>
                            <p>Optimized implementations with optional SIMD acceleration</p>
                        </div>
                        <div class="feature-card animate-on-scroll hover-lift magnetic-hover">
                            <div class="feature-icon animate-float stagger-2">üß∞</div>
                            <h3>Comprehensive</h3>
                            <p>Support for multiple curves and signature schemes</p>
                        </div>
                        <div class="feature-card animate-on-scroll hover-lift magnetic-hover">
                            <div class="feature-icon animate-float stagger-3">üìù</div>
                            <h3>Standards Compliant</h3>
                            <p>RFC compliance and interoperability with other libraries</p>
                        </div>
                    </div>
                </section>

                <!-- Installation Section -->
                <section id="installation" class="docs-section">
                    <h2>Installation</h2>
                    <p>Add Forge EC to your <code>Cargo.toml</code>:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Cargo.toml</span>
                            <button class="copy-btn" data-copy="[dependencies]
forge-ec-core = &quot;0.1&quot;
forge-ec-curves = &quot;0.1&quot;
forge-ec-signature = &quot;0.1&quot;
forge-ec-encoding = &quot;0.1&quot;
forge-ec-hash = &quot;0.1&quot;
forge-ec-rng = &quot;0.1&quot;">Copy</button>
                        </div>
                        <pre><code class="language-toml">[dependencies]
forge-ec-core = "0.1"
forge-ec-curves = "0.1"
forge-ec-signature = "0.1"
forge-ec-encoding = "0.1"
forge-ec-hash = "0.1"
forge-ec-rng = "0.1"</code></pre>
                    </div>

                    <h3>Feature Flags</h3>
                    <p>Forge EC supports various feature flags for customization:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Optional Features</span>
                            <button class="copy-btn">Copy</button>
                        </div>
                        <pre><code class="language-toml">[dependencies]
forge-ec-core = { version = "0.1", features = ["std", "simd"] }
forge-ec-curves = { version = "0.1", features = ["secp256k1", "p256", "ed25519"] }
forge-ec-signature = { version = "0.1", features = ["ecdsa", "eddsa", "schnorr"] }</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>Available Features</h4>
                        <ul>
                            <li><strong>std</strong>: Enable standard library support (default)</li>
                            <li><strong>alloc</strong>: Enable allocation support for no_std environments</li>
                            <li><strong>simd</strong>: Enable SIMD acceleration (AVX2, NEON)</li>
                            <li><strong>parallel</strong>: Enable parallel operations with rayon</li>
                            <li><strong>serde</strong>: Enable serialization support</li>
                        </ul>
                    </div>
                </section>

                <!-- Quick Start Section -->
                <section id="quick-start" class="docs-section">
                    <h2>Quick Start</h2>
                    <p>Get started with Forge EC in just a few lines of code:</p>

                    <div class="example-tabs">
                        <button class="tab-btn active" data-tab="ecdsa">ECDSA</button>
                        <button class="tab-btn" data-tab="eddsa">EdDSA</button>
                        <button class="tab-btn" data-tab="ecdh">ECDH</button>
                    </div>

                    <div class="tab-content active" id="ecdsa-tab">
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">ECDSA with secp256k1</span>
                                <button class="copy-btn">Copy</button>
                            </div>
                            <pre><code class="language-rust">use forge_ec_core::{Curve, SignatureScheme};
use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_signature::ecdsa::Ecdsa;
use forge_ec_rng::os_rng::OsRng;
use sha2::Sha256;

// Generate a key pair
let mut rng = OsRng::new();
let secret_key = Secp256k1::random_scalar(&mut rng);
let public_key = Secp256k1::multiply(&Secp256k1::generator(), &secret_key);
let public_key_affine = Secp256k1::to_affine(&public_key);

// Sign a message
let message = b"Hello, Cryptography!";
let signature = Ecdsa::<Secp256k1, Sha256>::sign(&secret_key, message);

// Verify the signature
let valid = Ecdsa::<Secp256k1, Sha256>::verify(&public_key_affine, message, &signature);
assert!(valid);</code></pre>
                        </div>
                    </div>

                    <div class="tab-content" id="eddsa-tab">
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">EdDSA with Ed25519</span>
                                <button class="copy-btn">Copy</button>
                            </div>
                            <pre><code class="language-rust">use forge_ec_signature::eddsa::Ed25519Signature;

// Generate a private key (32 bytes)
let private_key = [0u8; 32]; // Replace with your private key
let public_key = Ed25519Signature::derive_public_key(&private_key);

// Sign a message
let message = b"Hello, Ed25519!";
let signature = Ed25519Signature::sign(&private_key, message);

// Verify the signature
let valid = Ed25519Signature::verify(&public_key, message, &signature);
assert!(valid);</code></pre>
                        </div>
                    </div>

                    <div class="tab-content" id="ecdh-tab">
                        <div class="code-block">
                            <div class="code-header">
                                <span class="code-title">ECDH Key Exchange</span>
                                <button class="copy-btn">Copy</button>
                            </div>
                            <pre><code class="language-rust">use forge_ec_core::Curve;
use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_rng::os_rng::OsRng;

// Alice generates her key pair
let mut rng = OsRng::new();
let alice_sk = Secp256k1::random_scalar(&mut rng);
let alice_pk = Secp256k1::multiply(&Secp256k1::generator(), &alice_sk);

// Bob generates his key pair
let bob_sk = Secp256k1::random_scalar(&mut rng);
let bob_pk = Secp256k1::multiply(&Secp256k1::generator(), &bob_sk);

// Both parties compute the same shared secret
let alice_shared = Secp256k1::multiply(&bob_pk, &alice_sk);
let bob_shared = Secp256k1::multiply(&alice_pk, &bob_sk);

assert_eq!(alice_shared, bob_shared);</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Architecture Section -->
                <section id="architecture" class="docs-section">
                    <h2>Architecture</h2>
                    <p>Forge EC is designed with modularity and security in mind. The library is split into several crates:</p>

                    <div class="architecture-grid">
                        <div class="arch-card">
                            <h3>forge-ec-core</h3>
                            <p>Core traits and abstractions that define the API for elliptic curve operations.</p>
                            <ul>
                                <li>FieldElement trait</li>
                                <li>Scalar trait</li>
                                <li>Curve trait</li>
                                <li>SignatureScheme trait</li>
                            </ul>
                        </div>

                        <div class="arch-card">
                            <h3>forge-ec-curves</h3>
                            <p>Implementations of specific elliptic curves with optimized field arithmetic.</p>
                            <ul>
                                <li>secp256k1 (Bitcoin)</li>
                                <li>P-256 (NIST)</li>
                                <li>Ed25519 (Edwards)</li>
                                <li>Curve25519 (Montgomery)</li>
                            </ul>
                        </div>

                        <div class="arch-card">
                            <h3>forge-ec-signature</h3>
                            <p>Digital signature scheme implementations with constant-time operations.</p>
                            <ul>
                                <li>ECDSA with RFC6979</li>
                                <li>EdDSA (Ed25519)</li>
                                <li>Schnorr (BIP-340)</li>
                                <li>Batch verification</li>
                            </ul>
                        </div>

                        <div class="arch-card">
                            <h3>forge-ec-encoding</h3>
                            <p>Serialization and encoding formats for interoperability.</p>
                            <ul>
                                <li>DER encoding</li>
                                <li>PEM format</li>
                                <li>Point compression</li>
                                <li>Base58 encoding</li>
                            </ul>
                        </div>

                        <div class="arch-card">
                            <h3>forge-ec-hash</h3>
                            <p>Cryptographic hash functions and hash-to-curve operations.</p>
                            <ul>
                                <li>SHA-2 family</li>
                                <li>SHA-3 family</li>
                                <li>BLAKE2</li>
                                <li>RFC9380 hash-to-curve</li>
                            </ul>
                        </div>

                        <div class="arch-card">
                            <h3>forge-ec-rng</h3>
                            <p>Secure random number generation for cryptographic operations.</p>
                            <ul>
                                <li>OS random number generator</li>
                                <li>RFC6979 deterministic nonces</li>
                                <li>Constant-time operations</li>
                                <li>Entropy validation</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <!-- Core Traits Section -->
                <section id="core-traits" class="docs-section">
                    <h2>Core Traits</h2>
                    <p>Forge EC is built around a set of core traits that define the API for elliptic curve operations. These traits provide a consistent interface across different curve implementations.</p>

                    <h3>FieldElement Trait</h3>
                    <p>The <code>FieldElement</code> trait defines operations for finite field arithmetic:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">FieldElement Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait FieldElement:
    Clone + Copy + Debug + Default + Eq + PartialEq +
    Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self> + Neg<Output = Self>
{
    /// The zero element of the field
    const ZERO: Self;

    /// The one element of the field
    const ONE: Self;

    /// Returns true if this element is zero
    fn is_zero(&self) -> bool;

    /// Returns true if this element is one
    fn is_one(&self) -> bool;

    /// Computes the multiplicative inverse
    fn invert(&self) -> Option<Self>;

    /// Computes self^exp using square-and-multiply
    fn pow(&self, exp: &[u64]) -> Self;

    /// Returns the square root if it exists
    fn sqrt(&self) -> Option<Self>;
}</code></pre>
                    </div>

                    <h3>Scalar Trait</h3>
                    <p>The <code>Scalar</code> trait represents scalars for elliptic curve operations:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Scalar Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait Scalar:
    Clone + Copy + Debug + Default + Eq + PartialEq +
    Add<Output = Self> + Sub<Output = Self> + Mul<Output = Self> + Neg<Output = Self>
{
    /// The zero scalar
    const ZERO: Self;

    /// The one scalar
    const ONE: Self;

    /// Generate a random scalar
    fn random<R: CryptoRng + RngCore>(rng: &mut R) -> Self;

    /// Convert from bytes (little-endian)
    fn from_bytes(bytes: &[u8]) -> Option<Self>;

    /// Convert to bytes (little-endian)
    fn to_bytes(&self) -> Vec<u8>;

    /// Compute multiplicative inverse modulo the curve order
    fn invert(&self) -> Option<Self>;
}</code></pre>
                    </div>

                    <h3>Curve Trait</h3>
                    <p>The <code>Curve</code> trait defines the main elliptic curve operations:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Curve Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait Curve {
    type FieldElement: FieldElement;
    type Scalar: Scalar;
    type AffinePoint: Clone + Copy + Debug + Eq + PartialEq;
    type ProjectivePoint: Clone + Copy + Debug + Eq + PartialEq;

    /// The generator point of the curve
    fn generator() -> Self::ProjectivePoint;

    /// The identity (point at infinity)
    fn identity() -> Self::ProjectivePoint;

    /// Point multiplication: point * scalar
    fn multiply(point: &Self::ProjectivePoint, scalar: &Self::Scalar) -> Self::ProjectivePoint;

    /// Point addition
    fn add(a: &Self::ProjectivePoint, b: &Self::ProjectivePoint) -> Self::ProjectivePoint;

    /// Point doubling
    fn double(point: &Self::ProjectivePoint) -> Self::ProjectivePoint;

    /// Convert projective to affine coordinates
    fn to_affine(point: &Self::ProjectivePoint) -> Self::AffinePoint;

    /// Convert affine to projective coordinates
    fn to_projective(point: &Self::AffinePoint) -> Self::ProjectivePoint;

    /// Check if a point is on the curve
    fn is_on_curve(point: &Self::AffinePoint) -> bool;
}</code></pre>
                    </div>
                </section>

                <!-- Curves Section -->
                <section id="curves" class="docs-section">
                    <h2>Supported Curves</h2>
                    <p>Forge EC supports several widely-used elliptic curves, each optimized for specific use cases and security requirements.</p>

                    <div class="curve-grid">
                        <div class="curve-card animate-on-scroll hover-lift">
                            <h3>secp256k1</h3>
                            <p>The curve used by Bitcoin and many other cryptocurrencies. Provides 128-bit security level.</p>
                            <div class="curve-specs">
                                <div class="spec-item">
                                    <span class="spec-label">Field Size:</span>
                                    <span class="spec-value">256 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Security Level:</span>
                                    <span class="spec-value">128 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Standards:</span>
                                    <span class="spec-value">SEC 2</span>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-title">secp256k1 Usage</span>
                                    <button class="copy-btn">Copy</button>
                                </div>
                                <pre><code class="language-rust">use forge_ec_curves::secp256k1::Secp256k1;

// Generate a random scalar
let scalar = Secp256k1::random_scalar(&mut rng);

// Get the generator point
let generator = Secp256k1::generator();

// Perform scalar multiplication
let public_key = Secp256k1::multiply(&generator, &scalar);</code></pre>
                            </div>
                        </div>

                        <div class="curve-card animate-on-scroll hover-lift">
                            <h3>P-256 (NIST)</h3>
                            <p>NIST P-256 curve, widely used in government and enterprise applications. FIPS 186-4 approved.</p>
                            <div class="curve-specs">
                                <div class="spec-item">
                                    <span class="spec-label">Field Size:</span>
                                    <span class="spec-value">256 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Security Level:</span>
                                    <span class="spec-value">128 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Standards:</span>
                                    <span class="spec-value">FIPS 186-4, SEC 2</span>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-title">P-256 Usage</span>
                                    <button class="copy-btn">Copy</button>
                                </div>
                                <pre><code class="language-rust">use forge_ec_curves::p256::P256;

// Generate a key pair
let private_key = P256::random_scalar(&mut rng);
let public_key = P256::multiply(&P256::generator(), &private_key);

// Convert to affine coordinates for serialization
let public_key_affine = P256::to_affine(&public_key);</code></pre>
                            </div>
                        </div>

                        <div class="curve-card animate-on-scroll hover-lift">
                            <h3>Ed25519</h3>
                            <p>Edwards curve providing fast signature operations and built-in protection against side-channel attacks.</p>
                            <div class="curve-specs">
                                <div class="spec-item">
                                    <span class="spec-label">Field Size:</span>
                                    <span class="spec-value">255 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Security Level:</span>
                                    <span class="spec-value">128 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Standards:</span>
                                    <span class="spec-value">RFC 8032</span>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-title">Ed25519 Usage</span>
                                    <button class="copy-btn">Copy</button>
                                </div>
                                <pre><code class="language-rust">use forge_ec_curves::ed25519::Ed25519;

// Ed25519 uses a different API optimized for signatures
let private_key = [0u8; 32]; // Your 32-byte private key
let public_key = Ed25519::derive_public_key(&private_key);

// Sign a message
let message = b"Hello, Ed25519!";
let signature = Ed25519::sign(&private_key, message);</code></pre>
                            </div>
                        </div>

                        <div class="curve-card animate-on-scroll hover-lift">
                            <h3>Curve25519</h3>
                            <p>Montgomery curve optimized for Diffie-Hellman key exchange with excellent performance characteristics.</p>
                            <div class="curve-specs">
                                <div class="spec-item">
                                    <span class="spec-label">Field Size:</span>
                                    <span class="spec-value">255 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Security Level:</span>
                                    <span class="spec-value">128 bits</span>
                                </div>
                                <div class="spec-item">
                                    <span class="spec-label">Standards:</span>
                                    <span class="spec-value">RFC 7748</span>
                                </div>
                            </div>

                            <div class="code-block">
                                <div class="code-header">
                                    <span class="code-title">Curve25519 Usage</span>
                                    <button class="copy-btn">Copy</button>
                                </div>
                                <pre><code class="language-rust">use forge_ec_curves::curve25519::Curve25519;

// Generate key pairs for ECDH
let alice_private = Curve25519::random_scalar(&mut rng);
let alice_public = Curve25519::scalar_mult_base(&alice_private);

let bob_private = Curve25519::random_scalar(&mut rng);
let bob_public = Curve25519::scalar_mult_base(&bob_private);

// Compute shared secret
let shared_secret = Curve25519::scalar_mult(&alice_private, &bob_public);</code></pre>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Signatures Section -->
                <section id="signatures" class="docs-section">
                    <h2>Digital Signatures</h2>
                    <p>Forge EC provides comprehensive support for digital signature schemes with constant-time implementations and security-first design principles.</p>

                    <h3>Signature Trait</h3>
                    <p>All signature schemes implement the common <code>Signature</code> trait:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Signature Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait Signature<C: Curve> {
    type Error: std::error::Error;
    type Signature: Clone + Debug + PartialEq;

    /// Sign a message with the given private key
    fn sign(private_key: &C::Scalar, message: &[u8]) -> Result<Self::Signature, Self::Error>;

    /// Verify a signature against a message and public key
    fn verify(
        public_key: &C::AffinePoint,
        message: &[u8],
        signature: &Self::Signature
    ) -> bool;

    /// Batch verify multiple signatures (optional optimization)
    fn batch_verify(
        public_keys: &[C::AffinePoint],
        messages: &[&[u8]],
        signatures: &[Self::Signature]
    ) -> bool {
        // Default implementation verifies each signature individually
        public_keys.iter()
            .zip(messages.iter())
            .zip(signatures.iter())
            .all(|((pk, msg), sig)| Self::verify(pk, msg, sig))
    }
}</code></pre>
                    </div>

                    <h3>ECDSA (Elliptic Curve Digital Signature Algorithm)</h3>
                    <p>ECDSA is widely used in Bitcoin, Ethereum, and many other applications. Forge EC implements RFC6979 deterministic nonces for enhanced security.</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">ECDSA Implementation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::ecdsa::Ecdsa;
use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_rng::os_rng::OsRng;
use sha2::Sha256;

// Generate a key pair
let mut rng = OsRng::new();
let private_key = Secp256k1::random_scalar(&mut rng);
let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
let public_key_affine = Secp256k1::to_affine(&public_key);

// Sign a message
let message = b"Transaction: Alice sends 1 BTC to Bob";
let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)
    .expect("Signing failed");

// Verify the signature
let is_valid = Ecdsa::<Secp256k1, Sha256>::verify(
    &public_key_affine,
    message,
    &signature
);
assert!(is_valid);

// Serialize signature for transmission
let signature_bytes = signature.to_der();
let recovered_signature = EcdsaSignature::from_der(&signature_bytes)
    .expect("Invalid DER encoding");</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Security Warning</h4>
                        <p>Always use RFC6979 deterministic nonces (default in Forge EC) to prevent nonce reuse attacks. Never implement custom nonce generation unless you are a cryptography expert.</p>
                    </div>

                    <h3>EdDSA (Edwards-curve Digital Signature Algorithm)</h3>
                    <p>EdDSA provides fast signatures with built-in protection against many side-channel attacks. Ed25519 is the most common variant.</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Ed25519 Signatures</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::eddsa::Ed25519;
use forge_ec_rng::os_rng::OsRng;

// Generate a private key (32 random bytes)
let mut rng = OsRng::new();
let mut private_key = [0u8; 32];
rng.fill_bytes(&mut private_key);

// Derive the public key
let public_key = Ed25519::derive_public_key(&private_key);

// Sign a message
let message = b"Secure communication message";
let signature = Ed25519::sign(&private_key, message);

// Verify the signature
let is_valid = Ed25519::verify(&public_key, message, &signature);
assert!(is_valid);

// Ed25519 signatures are always 64 bytes
assert_eq!(signature.len(), 64);
assert_eq!(public_key.len(), 32);</code></pre>
                    </div>

                    <h3>Schnorr Signatures</h3>
                    <p>Schnorr signatures offer mathematical elegance and enable advanced features like signature aggregation. Forge EC implements BIP-340 for Bitcoin compatibility.</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Schnorr BIP-340</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::schnorr::SchnorrBip340;
use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_rng::os_rng::OsRng;

// Generate a key pair
let mut rng = OsRng::new();
let private_key = Secp256k1::random_scalar(&mut rng);

// For Schnorr, we need the x-only public key
let public_key_point = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
let public_key = SchnorrBip340::extract_x_only_public_key(&public_key_point);

// Sign a message
let message = b"Bitcoin Taproot transaction";
let signature = SchnorrBip340::sign(&private_key, message)
    .expect("Signing failed");

// Verify the signature
let is_valid = SchnorrBip340::verify(&public_key, message, &signature);
assert!(is_valid);

// Batch verification for multiple signatures
let signatures = vec![signature];
let public_keys = vec![public_key];
let messages = vec![message.as_slice()];

let batch_valid = SchnorrBip340::batch_verify(&public_keys, &messages, &signatures);
assert!(batch_valid);</code></pre>
                    </div>

                    <h3>Signature Aggregation</h3>
                    <p>Schnorr signatures support native aggregation, allowing multiple signatures to be combined into a single signature:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Signature Aggregation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::schnorr::{SchnorrBip340, AggregateSignature};

// Multiple signers
let mut rng = OsRng::new();
let private_key1 = Secp256k1::random_scalar(&mut rng);
let private_key2 = Secp256k1::random_scalar(&mut rng);

let public_key1 = SchnorrBip340::derive_public_key(&private_key1);
let public_key2 = SchnorrBip340::derive_public_key(&private_key2);

// Each signer signs the same message
let message = b"Multi-signature transaction";
let sig1 = SchnorrBip340::sign(&private_key1, message).unwrap();
let sig2 = SchnorrBip340::sign(&private_key2, message).unwrap();

// Aggregate the signatures
let aggregate_sig = AggregateSignature::new()
    .add_signature(sig1)
    .add_signature(sig2)
    .finalize();

// Verify the aggregate signature
let public_keys = vec![public_key1, public_key2];
let is_valid = aggregate_sig.verify(&public_keys, message);
assert!(is_valid);</code></pre>
                    </div>
                </section>

                <!-- Encoding Section -->
                <section id="encoding" class="docs-section">
                    <h2>Encoding and Serialization</h2>
                    <p>Forge EC provides comprehensive encoding support for interoperability with other cryptographic libraries and standards compliance.</p>

                    <h3>Encoding Trait</h3>
                    <p>All encodable types implement the <code>Encoding</code> trait:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Encoding Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait Encoding {
    type Error: std::error::Error;

    /// Encode to DER format
    fn to_der(&self) -> Vec<u8>;

    /// Decode from DER format
    fn from_der(bytes: &[u8]) -> Result<Self, Self::Error>
    where
        Self: Sized;

    /// Encode to PEM format with specified label
    fn to_pem(&self, label: &str) -> String {
        let der = self.to_der();
        pem::encode(&pem::Pem {
            tag: label.to_string(),
            contents: der,
        })
    }

    /// Decode from PEM format
    fn from_pem(pem_str: &str) -> Result<Self, Self::Error>
    where
        Self: Sized;
}</code></pre>
                    </div>

                    <h3>Point Compression</h3>
                    <p>Elliptic curve points can be compressed to save space while maintaining security:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Point Compression</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_encoding::point::{PointEncoding, CompressionFormat};
use forge_ec_curves::secp256k1::Secp256k1;

// Generate a point
let mut rng = OsRng::new();
let scalar = Secp256k1::random_scalar(&mut rng);
let point = Secp256k1::multiply(&Secp256k1::generator(), &scalar);
let affine_point = Secp256k1::to_affine(&point);

// Compress the point (33 bytes instead of 65)
let compressed = PointEncoding::encode_compressed(&affine_point);
assert_eq!(compressed.len(), 33);

// Decompress the point
let decompressed = PointEncoding::decode_compressed(&compressed)
    .expect("Invalid compressed point");
assert_eq!(affine_point, decompressed);

// Uncompressed encoding (65 bytes)
let uncompressed = PointEncoding::encode_uncompressed(&affine_point);
assert_eq!(uncompressed.len(), 65);

// SEC1 encoding with format byte
let sec1_compressed = PointEncoding::to_sec1_compressed(&affine_point);
let sec1_uncompressed = PointEncoding::to_sec1_uncompressed(&affine_point);</code></pre>
                    </div>

                    <h3>DER Encoding</h3>
                    <p>Distinguished Encoding Rules (DER) provide canonical ASN.1 encoding for cryptographic objects:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">DER Encoding Examples</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_encoding::der::{DerEncoding, PrivateKeyInfo, PublicKeyInfo};
use forge_ec_signature::ecdsa::EcdsaSignature;

// Encode private key to DER
let private_key = Secp256k1::random_scalar(&mut rng);
let private_key_der = PrivateKeyInfo::new(&private_key, Some(&Secp256k1::OID))
    .to_der();

// Decode private key from DER
let decoded_private_key = PrivateKeyInfo::from_der(&private_key_der)
    .expect("Invalid DER encoding")
    .private_key();

// Encode public key to DER
let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
let public_key_affine = Secp256k1::to_affine(&public_key);
let public_key_der = PublicKeyInfo::new(&public_key_affine, &Secp256k1::OID)
    .to_der();

// Encode signature to DER
let message = b"Test message";
let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message).unwrap();
let signature_der = signature.to_der();

// Decode signature from DER
let decoded_signature = EcdsaSignature::from_der(&signature_der)
    .expect("Invalid signature DER");</code></pre>
                    </div>

                    <h3>PEM Format</h3>
                    <p>Privacy-Enhanced Mail (PEM) format provides Base64 encoding with headers for easy text transmission:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">PEM Format Examples</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_encoding::pem::PemEncoding;

// Encode private key to PEM
let private_key_pem = private_key.to_pem("EC PRIVATE KEY");
println!("{}", private_key_pem);
// Output:
// -----BEGIN EC PRIVATE KEY-----
// MHcCAQEEIK8...
// -----END EC PRIVATE KEY-----

// Decode private key from PEM
let decoded_private_key = Secp256k1Scalar::from_pem(&private_key_pem)
    .expect("Invalid PEM format");

// Encode public key to PEM
let public_key_pem = public_key_affine.to_pem("PUBLIC KEY");

// Encode certificate signing request
let csr_pem = certificate_request.to_pem("CERTIFICATE REQUEST");</code></pre>
                    </div>

                    <h3>Base58 Encoding</h3>
                    <p>Base58 encoding is commonly used in Bitcoin and other cryptocurrencies for human-readable addresses:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Base58 Encoding</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_encoding::base58::{Base58, Base58Check};

// Simple Base58 encoding
let data = b"Hello, Bitcoin!";
let encoded = Base58::encode(data);
let decoded = Base58::decode(&encoded).expect("Invalid Base58");
assert_eq!(data, decoded.as_slice());

// Base58Check with checksum (Bitcoin addresses)
let public_key_hash = [0u8; 20]; // RIPEMD160(SHA256(public_key))
let version_byte = 0x00; // Bitcoin mainnet P2PKH

let address = Base58Check::encode_with_version(&public_key_hash, version_byte);
let (decoded_hash, decoded_version) = Base58Check::decode_with_version(&address)
    .expect("Invalid Bitcoin address");

assert_eq!(public_key_hash, decoded_hash.as_slice());
assert_eq!(version_byte, decoded_version);

// Validate checksum
let is_valid = Base58Check::verify_checksum(&address);
assert!(is_valid);</code></pre>
                    </div>

                    <h3>Hex Encoding</h3>
                    <p>Hexadecimal encoding for debugging and low-level operations:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Hex Encoding</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_encoding::hex::{ToHex, FromHex};

// Convert to hex string
let bytes = [0xde, 0xad, 0xbe, 0xef];
let hex_string = bytes.to_hex();
assert_eq!(hex_string, "deadbeef");

// Convert from hex string
let decoded_bytes = Vec::from_hex("deadbeef").expect("Invalid hex");
assert_eq!(bytes.to_vec(), decoded_bytes);

// Hex encoding with separators
let hex_with_colons = bytes.to_hex_with_separator(":");
assert_eq!(hex_with_colons, "de:ad:be:ef");

// Case-insensitive decoding
let upper_hex = "DEADBEEF";
let decoded_upper = Vec::from_hex(upper_hex).expect("Invalid hex");
assert_eq!(bytes.to_vec(), decoded_upper);</code></pre>
                    </div>
                </section>

                <!-- Hashing Section -->
                <section id="hashing" class="docs-section">
                    <h2>Cryptographic Hash Functions</h2>
                    <p>Forge EC provides secure hash function implementations and hash-to-curve operations compliant with RFC9380.</p>

                    <h3>Hash Trait</h3>
                    <p>All hash functions implement the <code>Hash</code> trait for consistent API:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Hash Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">pub trait Hash {
    /// Output size in bytes
    const OUTPUT_SIZE: usize;

    /// Block size in bytes
    const BLOCK_SIZE: usize;

    /// Hash a single message
    fn hash(data: &[u8]) -> Vec<u8>;

    /// Create a new hasher instance for streaming
    fn new() -> Self;

    /// Update the hasher with more data
    fn update(&mut self, data: &[u8]);

    /// Finalize and return the hash
    fn finalize(self) -> Vec<u8>;

    /// Reset the hasher to initial state
    fn reset(&mut self);
}</code></pre>
                    </div>

                    <h3>SHA-2 Family</h3>
                    <p>SHA-2 is the most widely used cryptographic hash function family:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">SHA-2 Usage</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_hash::sha2::{Sha256, Sha384, Sha512};

// SHA-256 (most common)
let message = b"Hello, cryptography!";
let hash = Sha256::hash(message);
assert_eq!(hash.len(), 32); // 256 bits = 32 bytes

// Streaming interface for large data
let mut hasher = Sha256::new();
hasher.update(b"Hello, ");
hasher.update(b"cryptography!");
let streaming_hash = hasher.finalize();
assert_eq!(hash, streaming_hash);

// SHA-384
let hash384 = Sha384::hash(message);
assert_eq!(hash384.len(), 48); // 384 bits = 48 bytes

// SHA-512
let hash512 = Sha512::hash(message);
assert_eq!(hash512.len(), 64); // 512 bits = 64 bytes

// HMAC with SHA-256
use forge_ec_hash::hmac::Hmac;
let key = b"secret_key";
let hmac = Hmac::<Sha256>::new(key);
let mac = hmac.finalize_with_message(message);</code></pre>
                    </div>

                    <h3>SHA-3 Family</h3>
                    <p>SHA-3 provides an alternative hash function design based on the Keccak sponge construction:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">SHA-3 Usage</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_hash::sha3::{Sha3_256, Sha3_384, Sha3_512, Keccak256};

// SHA3-256
let message = b"Keccak-based hashing";
let sha3_hash = Sha3_256::hash(message);
assert_eq!(sha3_hash.len(), 32);

// Keccak-256 (used in Ethereum)
let keccak_hash = Keccak256::hash(message);
assert_eq!(keccak_hash.len(), 32);

// Note: SHA3-256 and Keccak-256 produce different results
assert_ne!(sha3_hash, keccak_hash);

// SHAKE (extendable output functions)
use forge_ec_hash::sha3::{Shake128, Shake256};

let mut shake = Shake128::new();
shake.update(message);
let output_32 = shake.finalize_xof(32); // 32 bytes output
let output_64 = shake.finalize_xof(64); // 64 bytes output</code></pre>
                    </div>

                    <h3>BLAKE2</h3>
                    <p>BLAKE2 offers high performance and security with optional keying and personalization:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">BLAKE2 Usage</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_hash::blake2::{Blake2b, Blake2s, Blake2bParams, Blake2sParams};

// BLAKE2b (64-byte output)
let message = b"High-performance hashing";
let blake2b_hash = Blake2b::hash(message);
assert_eq!(blake2b_hash.len(), 64);

// BLAKE2s (32-byte output)
let blake2s_hash = Blake2s::hash(message);
assert_eq!(blake2s_hash.len(), 32);

// Keyed BLAKE2b (MAC functionality)
let key = b"authentication_key_32_bytes_long";
let keyed_hash = Blake2bParams::new()
    .key(key)
    .hash(message);

// Personalized BLAKE2b
let personalized_hash = Blake2bParams::new()
    .personal(b"MyApp1.0")
    .salt(b"random_salt_16b")
    .hash(message);

// Variable output length
let short_hash = Blake2bParams::new()
    .hash_length(16) // 16 bytes instead of 64
    .hash(message);
assert_eq!(short_hash.len(), 16);</code></pre>
                    </div>

                    <h3>Hash-to-Curve (RFC9380)</h3>
                    <p>RFC9380 compliant hash-to-curve operations for cryptographic protocols:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Hash-to-Curve Implementation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_hash::hash_to_curve::{HashToCurve, ExpandMessage};
use forge_ec_curves::secp256k1::Secp256k1;

// Hash-to-curve for secp256k1
let message = b"BLS signature aggregation";
let dst = b"FORGE_EC_SECP256K1_XMD:SHA-256_SSWU_RO_"; // Domain separation tag

let point = Secp256k1::hash_to_curve(message, dst)
    .expect("Hash-to-curve failed");

// Verify the point is on the curve
assert!(Secp256k1::is_on_curve(&Secp256k1::to_affine(&point)));

// Hash-to-scalar for deterministic key derivation
let scalar = Secp256k1::hash_to_scalar(message, dst);

// Expand message for uniform byte generation
let uniform_bytes = ExpandMessage::<Sha256>::expand_message_xmd(
    message,
    dst,
    48 // Output length
);

// Hash-to-field for field element generation
let field_elements = Secp256k1::hash_to_field(message, dst, 2);
assert_eq!(field_elements.len(), 2);</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üìö RFC9380 Compliance</h4>
                        <p>Forge EC implements the complete RFC9380 specification including:</p>
                        <ul>
                            <li><strong>Simplified SWU</strong>: For curves in short Weierstrass form</li>
                            <li><strong>Elligator 2</strong>: For Montgomery curves like Curve25519</li>
                            <li><strong>Ristretto</strong>: For Edwards curves with cofactor handling</li>
                            <li><strong>Domain Separation</strong>: Proper DST handling for security</li>
                        </ul>
                    </div>
                </section>

                <!-- Random Number Generation Section -->
                <section id="rng" class="docs-section">
                    <h2>Random Number Generation</h2>
                    <p>Secure random number generation is critical for cryptographic security. Forge EC provides multiple RNG sources with proper entropy validation.</p>

                    <h3>RNG Trait</h3>
                    <p>All random number generators implement the <code>CryptoRng</code> trait:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">CryptoRng Trait</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use rand_core::{RngCore, CryptoRng};

pub trait SecureRng: RngCore + CryptoRng {
    /// Fill a buffer with random bytes
    fn fill_bytes(&mut self, dest: &mut [u8]);

    /// Generate a random u32
    fn next_u32(&mut self) -> u32;

    /// Generate a random u64
    fn next_u64(&mut self) -> u64;

    /// Check if the RNG has sufficient entropy
    fn entropy_available(&self) -> bool;

    /// Reseed the RNG if possible
    fn reseed(&mut self) -> Result<(), RngError>;
}</code></pre>
                    </div>

                    <h3>OS Random Number Generator</h3>
                    <p>The OS RNG provides cryptographically secure random numbers from the operating system:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">OS RNG Usage</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_rng::os_rng::OsRng;
use forge_ec_curves::secp256k1::Secp256k1;

// Create OS RNG instance
let mut rng = OsRng::new();

// Generate random bytes
let mut random_bytes = [0u8; 32];
rng.fill_bytes(&mut random_bytes);

// Generate cryptographic keys
let private_key = Secp256k1::random_scalar(&mut rng);
let nonce = Secp256k1::random_scalar(&mut rng);

// Check entropy availability
if rng.entropy_available() {
    println!("Sufficient entropy available");
} else {
    eprintln!("Warning: Low entropy detected");
}

// Generate multiple random values
let random_u64 = rng.next_u64();
let random_u32 = rng.next_u32();</code></pre>
                    </div>

                    <h3>RFC6979 Deterministic Nonces</h3>
                    <p>RFC6979 provides deterministic nonce generation for signatures, eliminating nonce reuse vulnerabilities:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">RFC6979 Implementation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_rng::rfc6979::Rfc6979;
use forge_ec_hash::sha2::Sha256;

// RFC6979 deterministic nonce generation
let private_key = Secp256k1::random_scalar(&mut OsRng::new());
let message_hash = Sha256::hash(b"Message to sign");

let mut rfc6979 = Rfc6979::<Sha256>::new(&private_key.to_bytes(), &message_hash);

// Generate deterministic nonce
let nonce = rfc6979.next_k();

// The same inputs always produce the same nonce
let mut rfc6979_2 = Rfc6979::<Sha256>::new(&private_key.to_bytes(), &message_hash);
let nonce_2 = rfc6979_2.next_k();
assert_eq!(nonce, nonce_2);

// Different messages produce different nonces
let different_hash = Sha256::hash(b"Different message");
let mut rfc6979_3 = Rfc6979::<Sha256>::new(&private_key.to_bytes(), &different_hash);
let nonce_3 = rfc6979_3.next_k();
assert_ne!(nonce, nonce_3);</code></pre>
                    </div>

                    <h3>ChaCha20 RNG</h3>
                    <p>ChaCha20-based RNG for high-performance applications with reseeding capability:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">ChaCha20 RNG</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_rng::chacha::ChaCha20Rng;

// Create ChaCha20 RNG with OS entropy
let mut rng = ChaCha20Rng::from_entropy();

// Generate random data
let mut buffer = [0u8; 1024];
rng.fill_bytes(&mut buffer);

// Reseed periodically for forward secrecy
rng.reseed().expect("Reseeding failed");

// Create from seed (for testing only)
let seed = [42u8; 32];
let mut seeded_rng = ChaCha20Rng::from_seed(seed);

// Set custom stream position
rng.set_stream(1000);
let random_at_position = rng.next_u64();</code></pre>
                    </div>

                    <h3>Entropy Validation</h3>
                    <p>Forge EC includes entropy validation to detect weak random number generation:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Entropy Validation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_rng::entropy::{EntropyValidator, EntropyTest};

// Validate entropy quality
let mut rng = OsRng::new();
let mut samples = vec![0u8; 10000];
rng.fill_bytes(&mut samples);

let validator = EntropyValidator::new();

// Run statistical tests
let frequency_test = validator.frequency_test(&samples);
let runs_test = validator.runs_test(&samples);
let longest_run_test = validator.longest_run_test(&samples);

if frequency_test.passed && runs_test.passed && longest_run_test.passed {
    println!("Entropy quality is good");
} else {
    eprintln!("Warning: Poor entropy quality detected");
}

// Continuous monitoring
let mut monitor = validator.create_monitor();
monitor.add_sample(&samples);

if monitor.entropy_estimate() < 0.8 {
    eprintln!("Low entropy detected: {}", monitor.entropy_estimate());
}</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Security Warning</h4>
                        <p>Never use predictable or weak random number generators for cryptographic operations. Always use OS-provided entropy sources or well-tested CSPRNGs. Regularly validate entropy quality in production systems.</p>
                    </div>

                    <h3>Hardware RNG Support</h3>
                    <p>When available, Forge EC can utilize hardware random number generators:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Hardware RNG</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_rng::hardware::HardwareRng;

// Check for hardware RNG availability
if HardwareRng::is_available() {
    let mut hw_rng = HardwareRng::new().expect("Hardware RNG not available");

    // Use hardware RNG for key generation
    let private_key = Secp256k1::random_scalar(&mut hw_rng);

    // Mix with OS entropy for defense in depth
    let mut mixed_rng = hw_rng.mix_with_os_entropy();
    let secure_key = Secp256k1::random_scalar(&mut mixed_rng);
} else {
    // Fallback to OS RNG
    let mut rng = OsRng::new();
    let private_key = Secp256k1::random_scalar(&mut rng);
}</code></pre>
                    </div>
                </section>

                <!-- Security Considerations Section -->
                <section id="security" class="docs-section">
                    <h2>Security Considerations</h2>
                    <p>Forge EC is designed with security as the primary concern. This section outlines critical security practices and implementation details for safe cryptographic operations.</p>

                    <h3>Constant-Time Operations</h3>
                    <p>All cryptographic operations in Forge EC are implemented to run in constant time to prevent timing attacks:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Constant-Time Implementation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_security::constant_time::{ConstantTimeEq, ConditionalSelect};

// Constant-time comparison
let secret_key1 = Secp256k1::random_scalar(&mut rng);
let secret_key2 = Secp256k1::random_scalar(&mut rng);

// ‚ùå NEVER do this - vulnerable to timing attacks
// if secret_key1 == secret_key2 { ... }

// ‚úÖ Always use constant-time comparison
let keys_equal = secret_key1.ct_eq(&secret_key2);
if keys_equal.into() {
    println!("Keys are equal");
}

// Constant-time conditional selection
let condition = Choice::from(1u8); // or some computed condition
let selected_key = ConditionalSelect::conditional_select(
    &secret_key1,
    &secret_key2,
    condition
);

// Constant-time array operations
let mut sensitive_data = [0u8; 32];
rng.fill_bytes(&mut sensitive_data);

// Clear sensitive data securely
use forge_ec_security::zeroize::Zeroize;
sensitive_data.zeroize(); // Guaranteed to not be optimized away</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Critical Security Warning</h4>
                        <p>Never use standard comparison operators (==, !=) or conditional statements with secret data. Always use constant-time operations provided by Forge EC to prevent timing side-channel attacks.</p>
                    </div>

                    <h3>Side-Channel Attack Prevention</h3>
                    <p>Forge EC implements multiple layers of protection against various side-channel attacks:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Side-Channel Protection</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_security::side_channel::{BlindedScalar, PowerAnalysisResistant};

// Blinded scalar multiplication to prevent power analysis
let private_key = Secp256k1::random_scalar(&mut rng);
let blinded_key = BlindedScalar::new(private_key, &mut rng);

// Perform scalar multiplication with blinding
let public_key = Secp256k1::multiply_blinded(&Secp256k1::generator(), &blinded_key);

// Cache-timing attack resistance
use forge_ec_security::cache_resistant::CacheResistantLookup;

let precomputed_table = Secp256k1::generate_precomputed_table(&Secp256k1::generator());
let result = CacheResistantLookup::scalar_mult(&precomputed_table, &private_key);

// Electromagnetic emanation protection
#[cfg(feature = "em-protection")]
use forge_ec_security::em_shield::EMShield;

let mut protected_operation = EMShield::new();
let signature = protected_operation.execute(|| {
    Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)
}).expect("Protected signing failed");</code></pre>
                    </div>

                    <h3>Secure Key Management</h3>
                    <p>Proper key lifecycle management is essential for cryptographic security:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Secure Key Management</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_security::key_management::{SecureKey, KeyDerivation, KeyRotation};
use forge_ec_security::secure_storage::{EncryptedStorage, HSMInterface};

// Secure key generation with proper entropy
let mut secure_rng = OsRng::new();
let master_key = SecureKey::generate(&mut secure_rng);

// Key derivation using HKDF
let derived_key = KeyDerivation::hkdf_expand(
    &master_key,
    b"application_context",
    b"key_purpose_info",
    32 // output length
)?;

// Secure key storage
let encrypted_storage = EncryptedStorage::new("keystore.enc")?;
encrypted_storage.store_key("signing_key", &derived_key)?;

// Hardware Security Module integration
#[cfg(feature = "hsm")]
let hsm = HSMInterface::connect("pkcs11://token/slot")?;
let hsm_key = hsm.generate_key(KeyType::ECC_P256)?;

// Key rotation with forward secrecy
let mut key_rotator = KeyRotation::new(Duration::from_secs(3600)); // 1 hour
key_rotator.schedule_rotation(&master_key, |old_key, new_key| {
    // Migrate from old_key to new_key
    migrate_operations(old_key, new_key)
})?;

// Secure key destruction
impl Drop for SecureKey {
    fn drop(&mut self) {
        self.zeroize();
        // Additional secure deletion if needed
        #[cfg(target_os = "linux")]
        unsafe {
            libc::mlock(self.as_ptr() as *const libc::c_void, self.len());
            libc::munlock(self.as_ptr() as *const libc::c_void, self.len());
        }
    }
}</code></pre>
                    </div>

                    <h3>Memory Safety Guidelines</h3>
                    <p>Secure memory handling prevents information leakage and ensures data integrity:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Secure Memory Handling</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_security::secure_memory::{SecureVec, LockedMemory, SecureString};

// Use SecureVec for sensitive data
let mut secure_buffer = SecureVec::with_capacity(32);
secure_buffer.extend_from_slice(&sensitive_data);

// Memory locking to prevent swapping
let locked_memory = LockedMemory::new(1024)?; // 1KB locked page
let secure_workspace = locked_memory.as_mut_slice();

// Secure string handling
let mut secure_password = SecureString::new();
secure_password.push_str("user_password");
// Automatically zeroized on drop

// Stack protection for local variables
use forge_ec_security::stack_protection::StackGuard;

fn sensitive_operation() {
    let _guard = StackGuard::new(); // Protects stack frame

    let mut private_key = [0u8; 32];
    rng.fill_bytes(&mut private_key);

    // Perform cryptographic operations
    let signature = sign_message(&private_key, message);

    // Stack is automatically cleared when _guard drops
}

// Heap allocation security
use forge_ec_security::secure_allocator::SecureAllocator;

#[global_allocator]
static SECURE_ALLOC: SecureAllocator = SecureAllocator::new();

// All heap allocations are now secured and zeroized on deallocation</code></pre>
                    </div>

                    <h3>Input Validation and Sanitization</h3>
                    <p>Rigorous input validation prevents many cryptographic vulnerabilities:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Input Validation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_security::validation::{InputValidator, CurvePointValidator};

// Validate curve points before use
fn validate_public_key(point: &AffinePoint) -> Result<(), ValidationError> {
    let validator = CurvePointValidator::new();

    // Check if point is on curve
    validator.is_on_curve(point)?;

    // Check if point is not the identity
    validator.is_not_identity(point)?;

    // Check if point has correct order
    validator.has_correct_order(point)?;

    // Check for small subgroup attacks
    validator.not_in_small_subgroup(point)?;

    Ok(())
}

// Validate scalar values
fn validate_private_key(scalar: &Scalar) -> Result<(), ValidationError> {
    let validator = InputValidator::new();

    // Check if scalar is in valid range [1, n-1]
    validator.scalar_in_range(scalar)?;

    // Check if scalar is not zero
    validator.scalar_not_zero(scalar)?;

    Ok(())
}

// Signature validation
fn validate_signature(signature: &EcdsaSignature) -> Result<(), ValidationError> {
    let validator = InputValidator::new();

    // Validate r and s components
    validator.signature_component_valid(&signature.r)?;
    validator.signature_component_valid(&signature.s)?;

    // Check for malleability (ensure s is in lower half)
    validator.signature_not_malleable(signature)?;

    Ok(())
}

// Message length validation
fn validate_message(message: &[u8]) -> Result<(), ValidationError> {
    const MAX_MESSAGE_SIZE: usize = 1024 * 1024; // 1MB limit

    if message.is_empty() {
        return Err(ValidationError::EmptyMessage);
    }

    if message.len() > MAX_MESSAGE_SIZE {
        return Err(ValidationError::MessageTooLarge);
    }

    Ok(())
}</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üîí Security Best Practices</h4>
                        <ul>
                            <li><strong>Always validate inputs</strong>: Never trust external data without validation</li>
                            <li><strong>Use constant-time operations</strong>: Prevent timing side-channel attacks</li>
                            <li><strong>Implement proper key management</strong>: Generate, store, and destroy keys securely</li>
                            <li><strong>Regular security audits</strong>: Have your implementation reviewed by experts</li>
                            <li><strong>Keep dependencies updated</strong>: Use the latest versions with security fixes</li>
                            <li><strong>Monitor for vulnerabilities</strong>: Subscribe to security advisories</li>
                        </ul>
                    </div>

                    <h3>Common Security Pitfalls</h3>
                    <p>Avoid these common mistakes that can compromise cryptographic security:</p>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Common Pitfalls to Avoid</h4>
                        <ul>
                            <li><strong>Nonce Reuse</strong>: Never reuse nonces in ECDSA signatures</li>
                            <li><strong>Weak Random Numbers</strong>: Always use cryptographically secure RNGs</li>
                            <li><strong>Timing Attacks</strong>: Avoid variable-time operations with secrets</li>
                            <li><strong>Invalid Curve Points</strong>: Always validate points before operations</li>
                            <li><strong>Key Leakage</strong>: Properly zeroize sensitive data</li>
                            <li><strong>Implementation Bugs</strong>: Use well-tested cryptographic libraries</li>
                        </ul>
                    </div>
                </section>

                <!-- Performance Guide Section -->
                <section id="performance" class="docs-section">
                    <h2>Performance Guide</h2>
                    <p>Forge EC is optimized for high performance while maintaining security. This guide provides benchmarking data and optimization techniques.</p>

                    <h3>Benchmarking Results</h3>
                    <p>Performance benchmarks on modern hardware (Intel i7-12700K, 3.6GHz):</p>

                    <div class="performance-table">
                        <table class="benchmark-table">
                            <thead>
                                <tr>
                                    <th>Operation</th>
                                    <th>Curve</th>
                                    <th>Operations/sec</th>
                                    <th>Latency (Œºs)</th>
                                    <th>Memory (KB)</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Key Generation</td>
                                    <td>secp256k1</td>
                                    <td>85,000</td>
                                    <td>11.8</td>
                                    <td>0.5</td>
                                </tr>
                                <tr>
                                    <td>ECDSA Sign</td>
                                    <td>secp256k1</td>
                                    <td>45,000</td>
                                    <td>22.2</td>
                                    <td>1.2</td>
                                </tr>
                                <tr>
                                    <td>ECDSA Verify</td>
                                    <td>secp256k1</td>
                                    <td>15,000</td>
                                    <td>66.7</td>
                                    <td>2.1</td>
                                </tr>
                                <tr>
                                    <td>Ed25519 Sign</td>
                                    <td>Ed25519</td>
                                    <td>68,000</td>
                                    <td>14.7</td>
                                    <td>0.8</td>
                                </tr>
                                <tr>
                                    <td>Ed25519 Verify</td>
                                    <td>Ed25519</td>
                                    <td>22,000</td>
                                    <td>45.5</td>
                                    <td>1.5</td>
                                </tr>
                                <tr>
                                    <td>X25519 ECDH</td>
                                    <td>Curve25519</td>
                                    <td>35,000</td>
                                    <td>28.6</td>
                                    <td>1.0</td>
                                </tr>
                                <tr>
                                    <td>Schnorr Sign</td>
                                    <td>secp256k1</td>
                                    <td>42,000</td>
                                    <td>23.8</td>
                                    <td>1.3</td>
                                </tr>
                                <tr>
                                    <td>Schnorr Verify</td>
                                    <td>secp256k1</td>
                                    <td>18,000</td>
                                    <td>55.6</td>
                                    <td>2.0</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <h3>Optimization Techniques</h3>
                    <p>Several optimization strategies can significantly improve performance:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Performance Optimizations</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_performance::{Precomputation, BatchOperations, SIMDAcceleration};

// Precomputed tables for faster scalar multiplication
let precomputed_table = Secp256k1::precompute_table(&public_key, 8); // 8-bit window
let result = Secp256k1::scalar_mult_precomputed(&precomputed_table, &scalar);

// Batch verification for multiple signatures
let public_keys = vec![pk1, pk2, pk3, pk4];
let messages = vec![msg1, msg2, msg3, msg4];
let signatures = vec![sig1, sig2, sig3, sig4];

// ~4x faster than individual verification
let all_valid = Ecdsa::<Secp256k1, Sha256>::batch_verify(
    &public_keys,
    &messages,
    &signatures
);

// SIMD acceleration (requires target features)
#[cfg(target_feature = "avx2")]
use forge_ec_performance::simd::AVX2Backend;

let simd_backend = AVX2Backend::new();
let fast_result = simd_backend.scalar_mult(&point, &scalar);

// Memory pool for reduced allocations
use forge_ec_performance::memory::MemoryPool;

let mut pool = MemoryPool::new(1024 * 1024); // 1MB pool
let workspace = pool.allocate(256)?; // Reuse memory

// Parallel processing for independent operations
use rayon::prelude::*;

let signatures: Vec<_> = messages
    .par_iter()
    .zip(private_keys.par_iter())
    .map(|(msg, key)| Ecdsa::<Secp256k1, Sha256>::sign(key, msg))
    .collect();</code></pre>
                    </div>

                    <h3>SIMD Acceleration</h3>
                    <p>Forge EC supports SIMD instructions for enhanced performance on compatible hardware:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">SIMD Configuration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">// Cargo.toml configuration for SIMD
[dependencies]
forge-ec = { version = "0.1", features = ["simd", "avx2"] }

// Runtime SIMD detection
use forge_ec_performance::simd::{SIMDCapabilities, detect_simd};

let capabilities = detect_simd();
if capabilities.has_avx2() {
    println!("AVX2 acceleration available");
    let backend = AVX2Backend::new();
} else if capabilities.has_sse2() {
    println!("SSE2 acceleration available");
    let backend = SSE2Backend::new();
} else {
    println!("Using scalar implementation");
    let backend = ScalarBackend::new();
}

// Compile-time SIMD selection
#[cfg(target_feature = "avx2")]
const BACKEND: &dyn CryptoBackend = &AVX2Backend;

#[cfg(all(target_feature = "sse2", not(target_feature = "avx2")))]
const BACKEND: &dyn CryptoBackend = &SSE2Backend;

#[cfg(not(any(target_feature = "avx2", target_feature = "sse2")))]
const BACKEND: &dyn CryptoBackend = &ScalarBackend;</code></pre>
                    </div>

                    <h3>Memory Usage Guidelines</h3>
                    <p>Efficient memory usage is crucial for performance and security:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Memory Optimization</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_performance::memory::{StackAllocator, MemoryMetrics};

// Stack allocation for temporary data
let mut stack_alloc = StackAllocator::new(4096); // 4KB stack
let temp_buffer = stack_alloc.alloc::<u8>(256)?; // 256 bytes

// Memory usage monitoring
let metrics = MemoryMetrics::new();
metrics.start_monitoring();

// Perform operations
let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)?;

let usage = metrics.stop_monitoring();
println!("Peak memory usage: {} KB", usage.peak_kb());
println!("Allocations: {}", usage.allocation_count());

// Zero-copy operations where possible
use forge_ec_performance::zero_copy::ZeroCopyOps;

let message_slice = &large_message[offset..offset + chunk_size];
let hash = Sha256::hash_slice(message_slice); // No copying

// Memory-mapped files for large datasets
use forge_ec_performance::mmap::MemoryMappedFile;

let mmap_file = MemoryMappedFile::open("large_dataset.bin")?;
let data_slice = mmap_file.as_slice();
process_data_in_chunks(data_slice, 1024);</code></pre>
                    </div>

                    <h3>Compiler Optimizations</h3>
                    <p>Proper compiler configuration can significantly impact performance:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Cargo.toml Optimizations</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-toml"># Cargo.toml
[profile.release]
opt-level = 3              # Maximum optimization
lto = "fat"               # Link-time optimization
codegen-units = 1         # Single codegen unit for better optimization
panic = "abort"           # Smaller binary, faster execution
overflow-checks = false   # Disable integer overflow checks in release

[profile.release.build-override]
opt-level = 3

# Target-specific optimizations
[target.'cfg(target_arch = "x86_64")']
rustflags = [
    "-C", "target-cpu=native",     # Use all available CPU features
    "-C", "target-feature=+aes",   # Enable AES instructions
    "-C", "target-feature=+avx2",  # Enable AVX2 SIMD
]

# Features for maximum performance
[features]
default = ["std", "simd"]
simd = ["dep:wide"]
avx2 = ["simd"]
unsafe-optimizations = []  # Enable unsafe but faster code paths</code></pre>
                    </div>

                    <h3>Profiling and Measurement</h3>
                    <p>Use these tools to measure and optimize performance:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Performance Profiling</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_performance::profiling::{Profiler, BenchmarkSuite};

// Built-in profiler
let mut profiler = Profiler::new();

profiler.start("ecdsa_sign");
let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)?;
profiler.end("ecdsa_sign");

profiler.start("ecdsa_verify");
let valid = Ecdsa::<Secp256k1, Sha256>::verify(&public_key, message, &signature);
profiler.end("ecdsa_verify");

profiler.print_report();

// Criterion.rs integration for detailed benchmarks
use criterion::{criterion_group, criterion_main, Criterion, BenchmarkId};

fn bench_ecdsa_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("ECDSA");

    for curve in ["secp256k1", "p256"].iter() {
        group.bench_with_input(
            BenchmarkId::new("sign", curve),
            curve,
            |b, &curve| {
                b.iter(|| {
                    let signature = match curve {
                        "secp256k1" => ecdsa_sign_secp256k1(&key, &msg),
                        "p256" => ecdsa_sign_p256(&key, &msg),
                        _ => unreachable!(),
                    };
                    criterion::black_box(signature)
                });
            },
        );
    }

    group.finish();
}

criterion_group!(benches, bench_ecdsa_operations);
criterion_main!(benches);</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üöÄ Performance Tips</h4>
                        <ul>
                            <li><strong>Use batch operations</strong>: Verify multiple signatures together</li>
                            <li><strong>Precompute tables</strong>: For repeated operations with same base point</li>
                            <li><strong>Enable SIMD</strong>: Use hardware acceleration when available</li>
                            <li><strong>Pool memory</strong>: Reduce allocation overhead</li>
                            <li><strong>Profile regularly</strong>: Measure before optimizing</li>
                            <li><strong>Choose appropriate curves</strong>: Ed25519 is faster than ECDSA</li>
                        </ul>
                    </div>
                </section>

                <!-- Interoperability Section -->
                <section id="interop" class="docs-section">
                    <h2>Interoperability</h2>
                    <p>Forge EC is designed for seamless integration with existing cryptographic ecosystems and compliance with industry standards.</p>

                    <h3>RFC Compliance</h3>
                    <p>Forge EC implements multiple RFC specifications for maximum compatibility:</p>

                    <div class="info-box">
                        <h4>üìã Supported RFC Standards</h4>
                        <ul>
                            <li><strong>RFC 6979</strong>: Deterministic Usage of DSA and ECDSA</li>
                            <li><strong>RFC 8032</strong>: Edwards-Curve Digital Signature Algorithm (EdDSA)</li>
                            <li><strong>RFC 9380</strong>: Hashing to Elliptic Curves</li>
                            <li><strong>RFC 5915</strong>: Elliptic Curve Private Key Structure</li>
                            <li><strong>RFC 3279</strong>: Algorithms and Identifiers for X.509</li>
                            <li><strong>RFC 7748</strong>: Elliptic Curves for Security (Curve25519/Ed25519)</li>
                        </ul>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">RFC Compliance Examples</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::rfc::{Rfc6979, Rfc8032, Rfc9380};

// RFC 6979 deterministic ECDSA
let deterministic_sig = Rfc6979::ecdsa_sign(&private_key, &message_hash);

// RFC 8032 Ed25519 signatures
let ed25519_sig = Rfc8032::ed25519_sign(&ed_private_key, &message);

// RFC 9380 hash-to-curve
let curve_point = Rfc9380::hash_to_curve::<Secp256k1>(
    &message,
    b"FORGE_EC_SECP256K1_XMD:SHA-256_SSWU_RO_"
);

// Verify RFC compliance
assert!(Rfc6979::verify_deterministic(&deterministic_sig));
assert!(Rfc8032::verify_ed25519(&ed25519_sig));
assert!(Rfc9380::verify_hash_to_curve(&curve_point));</code></pre>
                    </div>

                    <h3>OpenSSL Integration</h3>
                    <p>Seamless integration with OpenSSL for existing applications:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">OpenSSL Compatibility</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::openssl::{OpenSSLCompat, EVP_PKEY};

// Convert Forge EC key to OpenSSL format
let forge_private_key = Secp256k1::random_scalar(&mut rng);
let openssl_key = OpenSSLCompat::to_evp_pkey(&forge_private_key)?;

// Use with OpenSSL functions
let openssl_signature = openssl::sign::Signer::new(
    openssl::hash::MessageDigest::sha256(),
    &openssl_key
)?.sign_oneshot(&message)?;

// Convert OpenSSL key to Forge EC
let imported_key = OpenSSLCompat::from_evp_pkey(&openssl_key)?;

// Cross-verify signatures
let forge_signature = Ecdsa::<Secp256k1, Sha256>::sign(&imported_key, &message)?;
let openssl_valid = OpenSSLCompat::verify_signature(
    &openssl_key,
    &message,
    &forge_signature.to_der()
)?;

assert!(openssl_valid);</code></pre>
                    </div>

                    <h3>libsecp256k1 Compatibility</h3>
                    <p>Drop-in replacement for libsecp256k1 with enhanced features:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">libsecp256k1 Migration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::libsecp256k1::{Secp256k1Compat, Context};

// Create context (similar to libsecp256k1)
let ctx = Context::new();

// Generate key pair
let (secret_key, public_key) = ctx.generate_keypair(&mut rng);

// Sign message (compatible API)
let message_hash = [0u8; 32]; // Your message hash
let signature = ctx.sign(&message_hash, &secret_key);

// Verify signature
let is_valid = ctx.verify(&message_hash, &signature, &public_key);
assert!(is_valid);

// Serialize keys in libsecp256k1 format
let secret_bytes = secret_key.serialize();
let public_bytes = public_key.serialize();
let public_compressed = public_key.serialize_compressed();

// Parse from libsecp256k1 format
let parsed_secret = SecretKey::parse(&secret_bytes)?;
let parsed_public = PublicKey::parse(&public_bytes)?;

// Recovery (for Ethereum compatibility)
let recovery_id = ctx.sign_recoverable(&message_hash, &secret_key);
let recovered_key = ctx.recover(&message_hash, &recovery_id)?;</code></pre>
                    </div>

                    <h3>Protocol Integration</h3>
                    <p>Integration examples for popular cryptographic protocols:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">TLS Integration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::tls::{TLSIntegration, ECDHEKeyExchange};

// ECDHE key exchange for TLS
let server_private = Secp256k1::random_scalar(&mut rng);
let client_private = Secp256k1::random_scalar(&mut rng);

let server_public = Secp256k1::multiply(&Secp256k1::generator(), &server_private);
let client_public = Secp256k1::multiply(&Secp256k1::generator(), &client_private);

// Compute shared secret
let server_shared = Secp256k1::multiply(&client_public, &server_private);
let client_shared = Secp256k1::multiply(&server_public, &client_private);

assert_eq!(server_shared, client_shared);

// Derive TLS master secret
let master_secret = TLSIntegration::derive_master_secret(
    &Secp256k1::to_affine(&server_shared),
    b"client_random_32_bytes_here_",
    b"server_random_32_bytes_here_"
)?;

// Generate TLS key material
let key_material = TLSIntegration::derive_key_material(
    &master_secret,
    b"key expansion",
    b"client_random_32_bytes_here_",
    b"server_random_32_bytes_here_",
    104 // key material length
)?;</code></pre>
                    </div>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Bitcoin Integration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::bitcoin::{BitcoinCompat, Address, Transaction};

// Generate Bitcoin key pair
let private_key = Secp256k1::random_scalar(&mut rng);
let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
let public_key_affine = Secp256k1::to_affine(&public_key);

// Create Bitcoin address
let address = BitcoinCompat::create_p2pkh_address(&public_key_affine, true)?; // mainnet
println!("Bitcoin address: {}", address);

// Sign Bitcoin transaction
let tx_hash = [0u8; 32]; // Transaction hash to sign
let signature = BitcoinCompat::sign_transaction(&private_key, &tx_hash)?;

// Create DER-encoded signature for Bitcoin
let der_signature = signature.to_der_with_sighash(0x01); // SIGHASH_ALL

// Verify Bitcoin signature
let is_valid = BitcoinCompat::verify_transaction(
    &public_key_affine,
    &tx_hash,
    &der_signature
)?;
assert!(is_valid);</code></pre>
                    </div>

                    <h3>Data Format Conversion</h3>
                    <p>Convert between different cryptographic data formats:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Format Conversion Utilities</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::formats::{FormatConverter, JWK, PKCS8, X509};

// Convert to JSON Web Key (JWK) format
let private_key = Secp256k1::random_scalar(&mut rng);
let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);

let jwk = FormatConverter::to_jwk(&private_key, &public_key)?;
println!("JWK: {}", serde_json::to_string_pretty(&jwk)?);

// Convert to PKCS#8 format
let pkcs8_der = FormatConverter::to_pkcs8_der(&private_key)?;
let pkcs8_pem = FormatConverter::to_pkcs8_pem(&private_key)?;

// Convert to X.509 SubjectPublicKeyInfo
let spki_der = FormatConverter::to_spki_der(&public_key)?;
let spki_pem = FormatConverter::to_spki_pem(&public_key)?;

// Parse from various formats
let parsed_from_jwk = FormatConverter::from_jwk(&jwk)?;
let parsed_from_pkcs8 = FormatConverter::from_pkcs8_der(&pkcs8_der)?;
let parsed_from_spki = FormatConverter::from_spki_der(&spki_der)?;

// Cross-format validation
assert_eq!(private_key, parsed_from_jwk.0);
assert_eq!(private_key, parsed_from_pkcs8);
assert_eq!(public_key, parsed_from_spki);</code></pre>
                    </div>

                    <h3>Migration Guide</h3>
                    <p>Step-by-step migration from other cryptographic libraries:</p>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è Migration Checklist</h4>
                        <ul>
                            <li><strong>Test thoroughly</strong>: Validate all cryptographic operations</li>
                            <li><strong>Verify compatibility</strong>: Ensure data formats match</li>
                            <li><strong>Update dependencies</strong>: Replace old library references</li>
                            <li><strong>Security audit</strong>: Review security-critical code paths</li>
                            <li><strong>Performance testing</strong>: Benchmark before and after migration</li>
                        </ul>
                    </div>
                </section>

                <!-- Testing Section -->
                <section id="testing" class="docs-section">
                    <h2>Testing</h2>
                    <p>Comprehensive testing is essential for cryptographic software. Forge EC provides extensive testing frameworks and methodologies.</p>

                    <h3>Unit Testing Framework</h3>
                    <p>Built-in testing utilities for cryptographic operations:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Unit Testing Example</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_testing::{TestVectors, CryptoTest, PropertyTest};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ecdsa_sign_verify() {
        let mut rng = OsRng::new();
        let private_key = Secp256k1::random_scalar(&mut rng);
        let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
        let public_key_affine = Secp256k1::to_affine(&public_key);

        let message = b"test message";
        let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)
            .expect("Signing should succeed");

        let is_valid = Ecdsa::<Secp256k1, Sha256>::verify(
            &public_key_affine,
            message,
            &signature
        );

        assert!(is_valid, "Signature verification should succeed");
    }

    #[test]
    fn test_invalid_signature_rejection() {
        let mut rng = OsRng::new();
        let private_key = Secp256k1::random_scalar(&mut rng);
        let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
        let public_key_affine = Secp256k1::to_affine(&public_key);

        let message = b"test message";
        let mut signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)
            .expect("Signing should succeed");

        // Corrupt the signature
        signature.r = Secp256k1::random_scalar(&mut rng);

        let is_valid = Ecdsa::<Secp256k1, Sha256>::verify(
            &public_key_affine,
            message,
            &signature
        );

        assert!(!is_valid, "Corrupted signature should be rejected");
    }
}</code></pre>
                    </div>

                    <h3>Test Vector Validation</h3>
                    <p>Validate against known test vectors from standards:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Test Vector Validation</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_testing::vectors::{RFC6979Vectors, Ed25519Vectors, Secp256k1Vectors};

#[test]
fn test_rfc6979_vectors() {
    let vectors = RFC6979Vectors::load();

    for vector in vectors.iter() {
        let private_key = Secp256k1Scalar::from_hex(&vector.private_key)
            .expect("Valid private key");
        let message = hex::decode(&vector.message)
            .expect("Valid message");
        let expected_k = Secp256k1Scalar::from_hex(&vector.expected_k)
            .expect("Valid k value");

        let mut rfc6979 = Rfc6979::<Sha256>::new(
            &private_key.to_bytes(),
            &Sha256::hash(&message)
        );

        let generated_k = rfc6979.next_k();
        assert_eq!(generated_k, expected_k, "RFC6979 k generation mismatch");

        let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, &message)
            .expect("Signing should succeed");

        assert_eq!(signature.r.to_hex(), vector.expected_r);
        assert_eq!(signature.s.to_hex(), vector.expected_s);
    }
}

#[test]
fn test_ed25519_vectors() {
    let vectors = Ed25519Vectors::load();

    for vector in vectors.iter() {
        let private_key = hex::decode(&vector.private_key)
            .expect("Valid private key");
        let public_key = hex::decode(&vector.public_key)
            .expect("Valid public key");
        let message = hex::decode(&vector.message)
            .expect("Valid message");
        let expected_signature = hex::decode(&vector.signature)
            .expect("Valid signature");

        // Test key derivation
        let derived_public = Ed25519::derive_public_key(&private_key);
        assert_eq!(derived_public, public_key, "Public key derivation mismatch");

        // Test signing
        let signature = Ed25519::sign(&private_key, &message);
        assert_eq!(signature, expected_signature, "Signature mismatch");

        // Test verification
        let is_valid = Ed25519::verify(&public_key, &message, &signature);
        assert!(is_valid, "Signature verification failed");
    }
}</code></pre>
                    </div>

                    <h3>Property-Based Testing</h3>
                    <p>Use property-based testing to verify cryptographic properties:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Property-Based Tests</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use proptest::prelude::*;
use forge_ec_testing::generators::{arbitrary_scalar, arbitrary_message};

proptest! {
    #[test]
    fn prop_ecdsa_sign_verify_roundtrip(
        private_key in arbitrary_scalar::<Secp256k1>(),
        message in arbitrary_message(1..1000)
    ) {
        let public_key = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
        let public_key_affine = Secp256k1::to_affine(&public_key);

        let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, &message)
            .expect("Signing should always succeed");

        let is_valid = Ecdsa::<Secp256k1, Sha256>::verify(
            &public_key_affine,
            &message,
            &signature
        );

        prop_assert!(is_valid, "Valid signature should always verify");
    }

    #[test]
    fn prop_signature_deterministic(
        private_key in arbitrary_scalar::<Secp256k1>(),
        message in arbitrary_message(1..1000)
    ) {
        let sig1 = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, &message)
            .expect("Signing should succeed");
        let sig2 = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, &message)
            .expect("Signing should succeed");

        prop_assert_eq!(sig1, sig2, "Signatures should be deterministic");
    }

    #[test]
    fn prop_different_keys_different_signatures(
        private_key1 in arbitrary_scalar::<Secp256k1>(),
        private_key2 in arbitrary_scalar::<Secp256k1>(),
        message in arbitrary_message(1..1000)
    ) {
        prop_assume!(private_key1 != private_key2);

        let sig1 = Ecdsa::<Secp256k1, Sha256>::sign(&private_key1, &message)
            .expect("Signing should succeed");
        let sig2 = Ecdsa::<Secp256k1, Sha256>::sign(&private_key2, &message)
            .expect("Signing should succeed");

        prop_assert_ne!(sig1, sig2, "Different keys should produce different signatures");
    }
}</code></pre>
                    </div>

                    <h3>Security Testing</h3>
                    <p>Specialized tests for security vulnerabilities:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Security Tests</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_testing::security::{TimingTest, SideChannelTest, FaultInjection};

#[test]
fn test_constant_time_operations() {
    let timing_test = TimingTest::new();

    // Test scalar multiplication timing
    let measurements = timing_test.measure_scalar_mult(1000);
    let timing_variance = measurements.coefficient_of_variation();

    assert!(
        timing_variance < 0.05,
        "Scalar multiplication should have low timing variance: {}",
        timing_variance
    );

    // Test signature verification timing
    let verify_measurements = timing_test.measure_signature_verify(1000);
    let verify_variance = verify_measurements.coefficient_of_variation();

    assert!(
        verify_variance < 0.05,
        "Signature verification should have low timing variance: {}",
        verify_variance
    );
}

#[test]
fn test_invalid_point_rejection() {
    // Test with point not on curve
    let invalid_point = AffinePoint {
        x: FieldElement::from(1u64),
        y: FieldElement::from(1u64),
    };

    let result = Secp256k1::is_on_curve(&invalid_point);
    assert!(!result, "Invalid point should be rejected");

    // Test with point at infinity
    let identity = Secp256k1::identity();
    let result = Secp256k1::multiply(&identity, &Secp256k1::random_scalar(&mut rng));
    assert_eq!(result, identity, "Multiplication by identity should return identity");
}

#[test]
fn test_signature_malleability_protection() {
    let mut rng = OsRng::new();
    let private_key = Secp256k1::random_scalar(&mut rng);
    let message = b"test message";

    let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)
        .expect("Signing should succeed");

    // Check that s is in lower half (malleability protection)
    let curve_order = Secp256k1::curve_order();
    let half_order = curve_order / 2u64.into();

    assert!(
        signature.s <= half_order,
        "Signature s component should be in lower half for malleability protection"
    );
}</code></pre>
                    </div>

                    <h3>Fuzzing Integration</h3>
                    <p>Continuous fuzzing to discover edge cases and vulnerabilities:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Fuzzing Setup</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">// fuzz/fuzz_targets/ecdsa_verify.rs
#![no_main]
use libfuzzer_sys::fuzz_target;
use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_signature::ecdsa::Ecdsa;

fuzz_target!(|data: &[u8]| {
    if data.len() < 96 {
        return; // Need at least 32 + 32 + 32 bytes
    }

    let public_key_bytes = &data[0..64];
    let signature_bytes = &data[64..96];
    let message = &data[96..];

    // Try to parse public key
    if let Ok(public_key) = AffinePoint::from_bytes(public_key_bytes) {
        // Try to parse signature
        if let Ok(signature) = EcdsaSignature::from_bytes(signature_bytes) {
            // Verify signature (should not panic)
            let _ = Ecdsa::<Secp256k1, Sha256>::verify(
                &public_key,
                message,
                &signature
            );
        }
    }
});

// Cargo.toml for fuzzing
[dependencies]
libfuzzer-sys = "0.4"

[[bin]]
name = "fuzz_ecdsa_verify"
path = "fuzz/fuzz_targets/ecdsa_verify.rs"
test = false
doc = false</code></pre>
                    </div>

                    <h3>Continuous Integration</h3>
                    <p>Automated testing pipeline for comprehensive validation:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">CI Configuration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-yaml"># .github/workflows/test.yml
name: Comprehensive Testing

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta, nightly]
        features: [default, simd, no-std]

    steps:
    - uses: actions/checkout@v3

    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        override: true
        components: rustfmt, clippy

    - name: Run tests
      run: |
        cargo test --features ${{ matrix.features }}
        cargo test --release --features ${{ matrix.features }}

    - name: Run property tests
      run: cargo test --features "proptest ${{ matrix.features }}"

    - name: Security tests
      run: cargo test --features "security-tests ${{ matrix.features }}"

    - name: Benchmark tests
      run: cargo bench --features ${{ matrix.features }}

    - name: Fuzz testing
      run: |
        cargo install cargo-fuzz
        cargo fuzz run ecdsa_verify -- -max_total_time=300

    - name: Code coverage
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --features ${{ matrix.features }} --out Xml

    - name: Upload coverage
      uses: codecov/codecov-action@v3</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üß™ Testing Best Practices</h4>
                        <ul>
                            <li><strong>Test all code paths</strong>: Ensure comprehensive coverage</li>
                            <li><strong>Use known test vectors</strong>: Validate against standards</li>
                            <li><strong>Property-based testing</strong>: Verify mathematical properties</li>
                            <li><strong>Security-focused tests</strong>: Check for vulnerabilities</li>
                            <li><strong>Continuous fuzzing</strong>: Discover edge cases</li>
                            <li><strong>Performance regression tests</strong>: Monitor performance</li>
                        </ul>
                    </div>
                </section>

                <!-- ECDSA Example Section -->
                <section id="ecdsa-example" class="docs-section">
                    <h2>ECDSA Signature Examples</h2>
                    <p>Complete working examples of ECDSA signatures with secp256k1 and P-256 curves, including error handling and real-world integration patterns.</p>

                    <h3>secp256k1 ECDSA (Bitcoin-style)</h3>
                    <p>ECDSA with secp256k1 curve, commonly used in Bitcoin and other cryptocurrencies:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Complete secp256k1 ECDSA Example</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_curves::secp256k1::Secp256k1;
use forge_ec_signature::ecdsa::Ecdsa;
use forge_ec_hash::sha2::Sha256;
use forge_ec_rng::os_rng::OsRng;
use forge_ec_encoding::hex::ToHex;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize secure random number generator
    let mut rng = OsRng::new();

    // Generate a private key (32 random bytes)
    let private_key = Secp256k1::random_scalar(&mut rng);
    println!("Private key: {}", private_key.to_hex());

    // Derive the corresponding public key
    let public_key_point = Secp256k1::multiply(&Secp256k1::generator(), &private_key);
    let public_key = Secp256k1::to_affine(&public_key_point);
    println!("Public key: ({}, {})", public_key.x.to_hex(), public_key.y.to_hex());

    // Message to sign (in practice, this would be a transaction hash)
    let message = b"Bitcoin transaction: Alice sends 0.5 BTC to Bob";
    println!("Message: {}", String::from_utf8_lossy(message));

    // Sign the message
    let signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)?;
    println!("Signature r: {}", signature.r.to_hex());
    println!("Signature s: {}", signature.s.to_hex());

    // Verify the signature
    let is_valid = Ecdsa::<Secp256k1, Sha256>::verify(&public_key, message, &signature);
    println!("Signature valid: {}", is_valid);

    // Demonstrate signature determinism (RFC 6979)
    let signature2 = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, message)?;
    assert_eq!(signature, signature2, "Signatures should be deterministic");
    println!("‚úì Deterministic signature generation verified");

    // Test with different message
    let different_message = b"Different transaction: Bob sends 0.3 BTC to Charlie";
    let different_signature = Ecdsa::<Secp256k1, Sha256>::sign(&private_key, different_message)?;

    // Verify wrong signature fails
    let wrong_verification = Ecdsa::<Secp256k1, Sha256>::verify(
        &public_key,
        message,
        &different_signature
    );
    assert!(!wrong_verification, "Wrong signature should fail verification");
    println!("‚úì Invalid signature correctly rejected");

    // Serialize signature for storage/transmission
    let signature_der = signature.to_der();
    println!("DER-encoded signature: {}", signature_der.to_hex());

    // Parse signature from DER
    let parsed_signature = EcdsaSignature::from_der(&signature_der)?;
    assert_eq!(signature, parsed_signature, "DER roundtrip should preserve signature");
    println!("‚úì DER encoding/decoding verified");

    Ok(())
}

// Bitcoin address generation example
fn generate_bitcoin_address(public_key: &AffinePoint) -> Result<String, Box<dyn std::error::Error>> {
    use forge_ec_hash::{sha2::Sha256, ripemd::Ripemd160};
    use forge_ec_encoding::base58::Base58Check;

    // Compress public key (33 bytes instead of 65)
    let compressed_pubkey = public_key.to_compressed_bytes();

    // Hash with SHA-256 then RIPEMD-160
    let sha256_hash = Sha256::hash(&compressed_pubkey);
    let ripemd160_hash = Ripemd160::hash(&sha256_hash);

    // Add version byte (0x00 for mainnet P2PKH)
    let address = Base58Check::encode_with_version(&ripemd160_hash, 0x00);

    Ok(address)
}</code></pre>
                    </div>

                    <h3>P-256 ECDSA (NIST Standard)</h3>
                    <p>ECDSA with NIST P-256 curve for government and enterprise applications:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">P-256 ECDSA Example</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_curves::p256::P256;
use forge_ec_signature::ecdsa::Ecdsa;
use forge_ec_hash::sha2::{Sha256, Sha384};
use forge_ec_encoding::der::DerEncoding;

fn p256_ecdsa_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = OsRng::new();

    // Generate P-256 key pair
    let private_key = P256::random_scalar(&mut rng);
    let public_key_point = P256::multiply(&P256::generator(), &private_key);
    let public_key = P256::to_affine(&public_key_point);

    println!("P-256 Key Pair Generated");
    println!("Private key size: {} bits", private_key.bit_length());
    println!("Public key size: {} bits", public_key.x.bit_length());

    // Sign with different hash functions
    let message = b"NIST P-256 digital signature test";

    // SHA-256 signature
    let sig_sha256 = Ecdsa::<P256, Sha256>::sign(&private_key, message)?;
    let valid_sha256 = Ecdsa::<P256, Sha256>::verify(&public_key, message, &sig_sha256);
    println!("SHA-256 signature valid: {}", valid_sha256);

    // SHA-384 signature (stronger hash)
    let sig_sha384 = Ecdsa::<P256, Sha384>::sign(&private_key, message)?;
    let valid_sha384 = Ecdsa::<P256, Sha384>::verify(&public_key, message, &sig_sha384);
    println!("SHA-384 signature valid: {}", valid_sha384);

    // Export keys in standard formats
    let private_key_der = private_key.to_pkcs8_der()?;
    let public_key_der = public_key.to_spki_der()?;

    println!("Private key DER size: {} bytes", private_key_der.len());
    println!("Public key DER size: {} bytes", public_key_der.len());

    // Import keys from DER
    let imported_private = P256Scalar::from_pkcs8_der(&private_key_der)?;
    let imported_public = P256AffinePoint::from_spki_der(&public_key_der)?;

    // Verify imported keys work
    let test_signature = Ecdsa::<P256, Sha256>::sign(&imported_private, message)?;
    let test_valid = Ecdsa::<P256, Sha256>::verify(&imported_public, message, &test_signature);
    assert!(test_valid, "Imported keys should work correctly");
    println!("‚úì Key import/export verified");

    Ok(())
}

// TLS integration example
fn tls_certificate_signing() -> Result<(), Box<dyn std::error::Error>> {
    use forge_ec_interop::x509::{CertificateBuilder, Extensions};

    let mut rng = OsRng::new();
    let ca_private_key = P256::random_scalar(&mut rng);
    let ca_public_key = P256::to_affine(&P256::multiply(&P256::generator(), &ca_private_key));

    // Create a certificate signing request
    let subject_private_key = P256::random_scalar(&mut rng);
    let subject_public_key = P256::to_affine(&P256::multiply(&P256::generator(), &subject_private_key));

    let certificate = CertificateBuilder::new()
        .subject("CN=example.com,O=Example Corp,C=US")
        .issuer("CN=Example CA,O=Example Corp,C=US")
        .public_key(&subject_public_key)
        .validity_days(365)
        .add_extension(Extensions::SubjectAltName(vec!["example.com", "www.example.com"]))
        .sign_with_ecdsa::<P256, Sha256>(&ca_private_key)?;

    println!("Certificate generated with {} bytes", certificate.to_der().len());

    Ok(())
}</code></pre>
                    </div>

                    <div class="warning-box">
                        <h4>‚ö†Ô∏è ECDSA Security Considerations</h4>
                        <ul>
                            <li><strong>Never reuse nonces</strong>: Always use RFC 6979 deterministic nonces</li>
                            <li><strong>Validate public keys</strong>: Ensure points are on the curve</li>
                            <li><strong>Check signature malleability</strong>: Use canonical s values</li>
                            <li><strong>Secure key storage</strong>: Protect private keys from disclosure</li>
                        </ul>
                    </div>
                </section>

                <!-- EdDSA Example Section -->
                <section id="eddsa-example" class="docs-section">
                    <h2>EdDSA Signature Examples</h2>
                    <p>Ed25519 implementation examples with proper key derivation, message signing, and batch verification optimizations.</p>

                    <h3>Basic Ed25519 Operations</h3>
                    <p>Fundamental Ed25519 signature operations with error handling:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Ed25519 Basic Example</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::eddsa::Ed25519;
use forge_ec_rng::os_rng::OsRng;
use forge_ec_encoding::hex::{ToHex, FromHex};

fn ed25519_basic_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = OsRng::new();

    // Generate a 32-byte private key
    let mut private_key = [0u8; 32];
    rng.fill_bytes(&mut private_key);

    println!("Ed25519 Private key: {}", private_key.to_hex());

    // Derive the public key (32 bytes)
    let public_key = Ed25519::derive_public_key(&private_key);
    println!("Ed25519 Public key: {}", public_key.to_hex());

    // Sign a message
    let message = b"Ed25519 signature test message";
    let signature = Ed25519::sign(&private_key, message);

    println!("Message: {}", String::from_utf8_lossy(message));
    println!("Signature: {}", signature.to_hex());
    println!("Signature length: {} bytes", signature.len());

    // Verify the signature
    let is_valid = Ed25519::verify(&public_key, message, &signature);
    println!("Signature valid: {}", is_valid);
    assert!(is_valid, "Signature should be valid");

    // Test with wrong message
    let wrong_message = b"Different message";
    let wrong_valid = Ed25519::verify(&public_key, wrong_message, &signature);
    assert!(!wrong_valid, "Wrong message should fail verification");
    println!("‚úì Invalid message correctly rejected");

    // Test with corrupted signature
    let mut corrupted_signature = signature;
    corrupted_signature[0] ^= 0x01; // Flip one bit
    let corrupted_valid = Ed25519::verify(&public_key, message, &corrupted_signature);
    assert!(!corrupted_valid, "Corrupted signature should fail verification");
    println!("‚úì Corrupted signature correctly rejected");

    Ok(())
}

// Key derivation from seed
fn ed25519_key_derivation() -> Result<(), Box<dyn std::error::Error>> {
    use forge_ec_hash::sha2::Sha512;
    use forge_ec_rng::pbkdf2::Pbkdf2;

    // Derive key from password and salt (for wallet applications)
    let password = b"user_password_123";
    let salt = b"application_salt";

    let mut derived_key = [0u8; 32];
    Pbkdf2::<Sha512>::derive(password, salt, 100_000, &mut derived_key)?;

    let public_key = Ed25519::derive_public_key(&derived_key);

    println!("Derived private key: {}", derived_key.to_hex());
    println!("Derived public key: {}", public_key.to_hex());

    // Test deterministic derivation
    let mut derived_key2 = [0u8; 32];
    Pbkdf2::<Sha512>::derive(password, salt, 100_000, &mut derived_key2)?;
    assert_eq!(derived_key, derived_key2, "Key derivation should be deterministic");
    println!("‚úì Deterministic key derivation verified");

    Ok(())
}</code></pre>
                    </div>

                    <h3>Batch Verification</h3>
                    <p>Efficient batch verification for multiple Ed25519 signatures:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">Ed25519 Batch Verification</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_signature::eddsa::{Ed25519, BatchVerifier};
use std::time::Instant;

fn ed25519_batch_verification() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = OsRng::new();

    // Generate multiple key pairs and signatures
    const NUM_SIGNATURES: usize = 100;
    let mut signatures = Vec::with_capacity(NUM_SIGNATURES);
    let mut public_keys = Vec::with_capacity(NUM_SIGNATURES);
    let mut messages = Vec::with_capacity(NUM_SIGNATURES);

    println!("Generating {} signatures for batch verification...", NUM_SIGNATURES);

    for i in 0..NUM_SIGNATURES {
        let mut private_key = [0u8; 32];
        rng.fill_bytes(&mut private_key);

        let public_key = Ed25519::derive_public_key(&private_key);
        let message = format!("Message number {}", i).into_bytes();
        let signature = Ed25519::sign(&private_key, &message);

        public_keys.push(public_key);
        messages.push(message);
        signatures.push(signature);
    }

    // Individual verification (baseline)
    let start_individual = Instant::now();
    let mut individual_results = Vec::new();
    for i in 0..NUM_SIGNATURES {
        let valid = Ed25519::verify(&public_keys[i], &messages[i], &signatures[i]);
        individual_results.push(valid);
    }
    let individual_time = start_individual.elapsed();

    let all_individual_valid = individual_results.iter().all(|&v| v);
    println!("Individual verification: {} valid, took {:?}",
             individual_results.iter().filter(|&&v| v).count(),
             individual_time);

    // Batch verification (optimized)
    let start_batch = Instant::now();
    let batch_valid = Ed25519::batch_verify(&public_keys, &messages, &signatures);
    let batch_time = start_batch.elapsed();

    println!("Batch verification: {} valid, took {:?}",
             if batch_valid { NUM_SIGNATURES } else { 0 },
             batch_time);

    assert_eq!(all_individual_valid, batch_valid, "Batch and individual results should match");

    let speedup = individual_time.as_nanos() as f64 / batch_time.as_nanos() as f64;
    println!("Batch verification speedup: {:.2}x", speedup);

    // Test with one invalid signature
    let mut corrupted_signatures = signatures.clone();
    corrupted_signatures[50][0] ^= 0x01; // Corrupt one signature

    let batch_invalid = Ed25519::batch_verify(&public_keys, &messages, &corrupted_signatures);
    assert!(!batch_invalid, "Batch verification should fail with invalid signature");
    println!("‚úì Batch verification correctly rejects invalid signatures");

    Ok(())
}</code></pre>
                    </div>

                    <h3>SSH Integration</h3>
                    <p>Ed25519 integration with SSH for secure authentication:</p>

                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">SSH Ed25519 Integration</span>
                            <button class="copy-btn hover-glow">Copy</button>
                        </div>
                        <pre><code class="language-rust">use forge_ec_interop::ssh::{SshKeyFormat, SshSignature};
use forge_ec_encoding::base64::Base64;

fn ssh_ed25519_example() -> Result<(), Box<dyn std::error::Error>> {
    let mut rng = OsRng::new();

    // Generate SSH Ed25519 key pair
    let mut private_key = [0u8; 32];
    rng.fill_bytes(&mut private_key);
    let public_key = Ed25519::derive_public_key(&private_key);

    // Format as SSH public key
    let ssh_public_key = SshKeyFormat::ed25519_public_key(&public_key, "user@example.com")?;
    println!("SSH public key:\n{}", ssh_public_key);

    // SSH authentication challenge
    let challenge_data = b"SSH authentication challenge";
    let signature = Ed25519::sign(&private_key, challenge_data);

    // Format as SSH signature
    let ssh_signature = SshSignature::new("ssh-ed25519", &signature);
    let ssh_sig_blob = ssh_signature.to_wire_format()?;

    println!("SSH signature blob: {}", Base64::encode(&ssh_sig_blob));

    // Verify SSH signature
    let parsed_signature = SshSignature::from_wire_format(&ssh_sig_blob)?;
    let is_valid = Ed25519::verify(&public_key, challenge_data, &parsed_signature.signature);

    assert!(is_valid, "SSH signature should be valid");
    println!("‚úì SSH Ed25519 authentication verified");

    // Generate SSH private key file format
    let ssh_private_key = SshKeyFormat::ed25519_private_key(&private_key, "user@example.com")?;
    println!("SSH private key format generated ({} bytes)", ssh_private_key.len());

    Ok(())
}

// Certificate signing with Ed25519
fn ed25519_certificate_example() -> Result<(), Box<dyn std::error::Error>> {
    use forge_ec_interop::x509::{CertificateBuilder, SignatureAlgorithm};

    let mut rng = OsRng::new();

    // CA key pair
    let mut ca_private_key = [0u8; 32];
    rng.fill_bytes(&mut ca_private_key);
    let ca_public_key = Ed25519::derive_public_key(&ca_private_key);

    // Subject key pair
    let mut subject_private_key = [0u8; 32];
    rng.fill_bytes(&mut subject_private_key);
    let subject_public_key = Ed25519::derive_public_key(&subject_private_key);

    // Create certificate with Ed25519 signature
    let certificate = CertificateBuilder::new()
        .subject("CN=ed25519.example.com,O=Example Corp")
        .issuer("CN=Ed25519 CA,O=Example Corp")
        .public_key_ed25519(&subject_public_key)
        .validity_days(90)
        .signature_algorithm(SignatureAlgorithm::Ed25519)
        .sign_ed25519(&ca_private_key)?;

    println!("Ed25519 certificate generated");
    println!("Certificate size: {} bytes", certificate.to_der().len());

    // Verify certificate signature
    let cert_valid = certificate.verify_signature_ed25519(&ca_public_key)?;
    assert!(cert_valid, "Certificate signature should be valid");
    println!("‚úì Ed25519 certificate signature verified");

    Ok(())
}</code></pre>
                    </div>

                    <div class="info-box">
                        <h4>üöÄ Ed25519 Advantages</h4>
                        <ul>
                            <li><strong>High Performance</strong>: Faster than ECDSA for both signing and verification</li>
                            <li><strong>Small Signatures</strong>: Only 64 bytes per signature</li>
                            <li><strong>Deterministic</strong>: No nonce generation required</li>
                            <li><strong>Side-Channel Resistant</strong>: Built-in protection against timing attacks</li>
                            <li><strong>Batch Verification</strong>: Efficient verification of multiple signatures</li>
                        </ul>
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- Scripts -->
    <script src="../js/prism.js"></script>
    <script src="../js/docs.js"></script>
</body>
</html>
