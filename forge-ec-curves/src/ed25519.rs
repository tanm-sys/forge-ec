//! High-performance, constant-time implementation of the Ed25519 Edwards curve.
//!
//! This module provides a complete implementation of Ed25519 as specified in RFC 8032.
//! Ed25519 is a twisted Edwards curve with the equation:
//!
//! ```text
//! -x² + y² = 1 + d·x²·y²
//! ```
//!
//! Where:
//! - `p = 2^255 - 19` (base field modulus)
//! - `d = -121665/121666` (curve parameter)
//! - `l = 2^252 + 27742317777372353535851937790883648493` (scalar field order)
//!
//! # Security Features
//!
//! - **Constant-time operations**: All secret-dependent operations are implemented
//!   in constant time to prevent timing attacks
//! - **Side-channel resistance**: Uses Montgomery ladder and other techniques
//!   to resist side-channel attacks
//! - **RFC 8032 compliance**: Fully compliant with the Ed25519 specification
//! - **Memory safety**: Automatic zeroization of sensitive data
//!
//! # Performance Features
//!
//! - **Optimized field arithmetic**: Uses efficient reduction algorithms
//! - **Extended coordinates**: Uses extended twisted Edwards coordinates for efficiency
//! - **Precomputed tables**: Uses precomputed multiples for faster scalar multiplication
//! - **SIMD-friendly**: Designed to work well with vectorized operations
//!
//! # Examples
//!
//! ```rust
//! use forge_ec_curves::ed25519::{Ed25519, FieldElement, Scalar};
//! use forge_ec_core::{Curve, FieldElement as CoreFieldElement};
//! use rand_core::OsRng;
//!
//! // Generate a random scalar
//! let mut rng = OsRng;
//! let scalar = Scalar::random(&mut rng);
//!
//! // Perform scalar multiplication
//! let point = Ed25519::multiply(&Ed25519::generator(), &scalar);
//!
//! // Convert to affine coordinates
//! let affine_point = Ed25519::to_affine(&point);
//! ```

use core::ops::{Add, AddAssign, Mul, MulAssign, Neg, Sub, SubAssign};

use forge_ec_core::{Curve, FieldElement as CoreFieldElement, PointAffine, PointProjective};
use std::{vec, vec::Vec};
use subtle::{Choice, ConditionallySelectable, ConstantTimeEq, CtOption};
use zeroize::Zeroize;

// ================================================================================================
// Ed25519 Curve Constants
// ================================================================================================

/// The Ed25519 base field modulus: p = 2^255 - 19
///
/// This is the prime that defines the base field F_p over which the curve is defined.
/// All field arithmetic is performed modulo this prime.
const P: [u64; 4] = [
    0xFFFF_FFFF_FFFF_FFED, // p mod 2^64
    0xFFFF_FFFF_FFFF_FFFF, // (p >> 64) mod 2^64
    0xFFFF_FFFF_FFFF_FFFF, // (p >> 128) mod 2^64
    0x7FFF_FFFF_FFFF_FFFF, // (p >> 192) mod 2^64
];

/// The Ed25519 scalar field order: l = 2^252 + 27742317777372353535851937790883648493
///
/// This is the order of the base point, i.e., the number of points in the cyclic
/// subgroup generated by the base point. All scalar arithmetic is performed modulo this value.
const L: [u64; 4] = [
    0x5812_631A_5CF5_D3ED, // l mod 2^64
    0x14DE_F9DE_A2F7_9CD6, // (l >> 64) mod 2^64
    0x0000_0000_0000_0000, // (l >> 128) mod 2^64
    0x1000_0000_0000_0000, // (l >> 192) mod 2^64
];

/// The Ed25519 curve parameter d = -121665/121666 mod p
///
/// This is the curve parameter in the twisted Edwards equation:
/// -x² + y² = 1 + d·x²·y²
const D: [u64; 4] = [
    0x75EB_4DCA_135E_DEFF, // d mod 2^64
    0x00E0_149A_8283_B156, // (d >> 64) mod 2^64
    0x198E_80F2_EEF3_D130, // (d >> 128) mod 2^64
    0x2406_875C_C61A_8E3C, // (d >> 192) mod 2^64
];

/// The Ed25519 base point x-coordinate
///
/// This is the x-coordinate of the standard base point used for Ed25519.
/// Currently unused but kept for future point arithmetic implementations.
#[allow(dead_code)]
const BASE_POINT_X: [u64; 4] = [
    0x1AD5_258F_602D_56C9, // x mod 2^64
    0x2F25_D2FC_D265_8E1B, // (x >> 64) mod 2^64
    0x6823_7A3C_0F13_6C79, // (x >> 128) mod 2^64
    0x216D_AAAA_AAAA_AAA9, // (x >> 192) mod 2^64
];

/// The Ed25519 base point y-coordinate
///
/// This is the y-coordinate of the standard base point used for Ed25519.
/// Currently unused but kept for future point arithmetic implementations.
#[allow(dead_code)]
const BASE_POINT_Y: [u64; 4] = [
    0x6666_6666_6666_6658, // y mod 2^64
    0x6666_6666_6666_6666, // (y >> 64) mod 2^64
    0x6666_6666_6666_6666, // (y >> 128) mod 2^64
    0x6666_6666_6666_6666, // (y >> 192) mod 2^64
];

/// Precomputed value: 2*d mod p
///
/// This is used in point addition formulas for efficiency.
/// Currently unused but kept for future optimized point arithmetic implementations.
#[allow(dead_code)]
const D2: [u64; 4] = [
    0xEBD6_9B94_26BD_BFDF, // 2*d mod 2^64
    0x01C0_2935_0507_62AC, // (2*d >> 64) mod 2^64
    0x331D_01E5_DDE7_A260, // (2*d >> 128) mod 2^64
    0x480D_0EB9_8C35_1C78, // (2*d >> 192) mod 2^64
];

/// Precomputed value: sqrt(-1) mod p
///
/// This is used for point decompression and other operations.
const SQRT_M1: [u64; 4] = [
    0xC4EE_1B27_4A0E_A0B0, // sqrt(-1) mod 2^64
    0x2F43_1806_AD2F_E478, // (sqrt(-1) >> 64) mod 2^64
    0x2B4D_0099_3DFB_D7A7, // (sqrt(-1) >> 128) mod 2^64
    0x2B83_2480_4FC1_DF0B, // (sqrt(-1) >> 192) mod 2^64
];

// ================================================================================================
// Field Element Implementation
// ================================================================================================

/// A field element in the Ed25519 base field F_p where p = 2^255 - 19.
///
/// This type represents elements of the finite field over which the Ed25519 curve is defined.
/// All operations are implemented to be constant-time when operating on secret data.
///
/// # Internal Representation
///
/// Field elements are stored as four 64-bit limbs in little-endian order, representing
/// a 256-bit integer. The value is always kept in the range [0, p-1] through reduction.
///
/// # Security Considerations
///
/// - All arithmetic operations are constant-time
/// - Memory is automatically zeroized when the element is dropped
/// - No secret-dependent branches or memory accesses
///
/// # Examples
///
/// ```rust
/// use forge_ec_curves::ed25519::FieldElement;
/// use forge_ec_core::FieldElement as CoreFieldElement;
///
/// let a = FieldElement::one();
/// let b = FieldElement::from_u64(42);
/// let c = a + b;
/// assert!(!bool::from(c.is_zero()));
/// ```
#[derive(Copy, Clone, Debug, Default)]
pub struct FieldElement([u64; 4]);

impl FieldElement {
    /// Creates a new field element from raw limbs.
    ///
    /// # Security Note
    ///
    /// The caller must ensure that the raw limbs represent a value less than p.
    /// This function does not perform reduction.
    pub const fn from_raw(raw: [u64; 4]) -> Self {
        Self(raw)
    }

    /// Returns the raw limbs of this field element.
    ///
    /// The limbs are returned in little-endian order.
    pub const fn to_raw(&self) -> [u64; 4] {
        self.0
    }

    /// Creates a new field element from a u64 value.
    ///
    /// This is equivalent to `FieldElement::from_raw([value, 0, 0, 0])`.
    pub const fn from_u64(value: u64) -> Self {
        Self([value, 0, 0, 0])
    }

    /// Performs constant-time field reduction modulo p = 2^255 - 19.
    ///
    /// This function reduces the field element to the canonical range [0, p-1].
    /// The implementation is constant-time to prevent timing attacks.
    ///
    /// # Algorithm
    ///
    /// The reduction uses the fact that p = 2^255 - 19, so:
    /// - 2^255 ≡ 19 (mod p)
    /// - Any value >= 2^255 can be reduced by subtracting 2^255 and adding 19
    ///
    /// The algorithm performs the following steps:
    /// 1. If the top bit (bit 255) is set, clear it and add 19
    /// 2. If the result is still >= p, subtract p
    ///
    /// Both steps are performed in constant time using conditional operations.
    fn reduce(&mut self) {
        // Step 1: Handle the top bit (bit 255)
        // Extract the top bit and clear it
        let top_bit = self.0[3] >> 63;
        self.0[3] &= 0x7FFF_FFFF_FFFF_FFFF;

        // If top bit was set, add 19 (constant-time)
        let mut carry = top_bit * 19;
        for i in 0..4 {
            let sum = self.0[i] as u128 + carry as u128;
            self.0[i] = sum as u64;
            carry = (sum >> 64) as u64;
        }

        // Step 2: Check if result >= p and subtract p if necessary
        // This is done in constant time using conditional subtraction

        // Compute self - p
        let mut diff = [0u64; 4];
        let mut borrow = 0u64;
        for i in 0..4 {
            let (d1, b1) = self.0[i].overflowing_sub(P[i]);
            let (d2, b2) = d1.overflowing_sub(borrow);
            diff[i] = d2;
            borrow = (b1 as u64) + (b2 as u64);
        }

        // If no borrow occurred, self >= p, so use the difference
        // Otherwise, keep the original value
        let use_diff = Choice::from((borrow == 0) as u8);
        for i in 0..4 {
            self.0[i] = u64::conditional_select(&self.0[i], &diff[i], use_diff);
        }
    }

    /// Performs optimized reduction for the result of multiplication.
    ///
    /// This function takes a 512-bit product (represented as 8 limbs) and reduces
    /// it modulo p = 2^255 - 19 using an optimized algorithm.
    ///
    /// # Algorithm
    ///
    /// The reduction uses the identity 2^255 ≡ 19 (mod p) to reduce the high bits:
    /// - Split the 512-bit value into low 255 bits and high bits
    /// - Multiply high bits by 19 and add to low bits
    /// - Perform final reduction if necessary
    fn reduce_wide(limbs: &[u64; 8]) -> Self {
        // Split into low 4 limbs and high 4 limbs
        let mut low = [limbs[0], limbs[1], limbs[2], limbs[3]];
        let high = [limbs[4], limbs[5], limbs[6], limbs[7]];

        // Multiply high part by 19 and add to low part
        // This implements: low + high * 2^256 ≡ low + high * 19 * 2^255 ≡ low + high * 19 * 19 (mod p)
        // But we use the fact that 2^256 = 38 (mod p) since 2^255 = 19 (mod p)

        let mut carry = 0u128;
        for i in 0..4 {
            // Multiply high[i] by 38 and add to low
            let product = (high[i] as u128) * 38u128 + (low[i] as u128) + carry;
            low[i] = product as u64;
            carry = product >> 64;
        }

        // Handle final carry by multiplying by 19 (since carry represents multiples of 2^256)
        let mut final_carry = (carry as u64) * 19;
        for i in 0..4 {
            let sum = (low[i] as u128) + (final_carry as u128);
            low[i] = sum as u64;
            final_carry = (sum >> 64) as u64;
        }

        // Create result and perform final reduction
        let mut result = Self(low);
        result.reduce();
        result
    }

    /// Converts this field element to a 32-byte array in little-endian format.
    ///
    /// This function ensures the field element is in canonical form before conversion.
    /// The output format matches the Ed25519 specification.
    pub fn to_bytes(&self) -> [u8; 32] {
        // Ensure the element is in canonical form
        let mut canonical = *self;
        canonical.reduce();

        let mut bytes = [0u8; 32];

        // Convert from little-endian limbs to little-endian bytes
        for i in 0..4 {
            let limb_bytes = canonical.0[i].to_le_bytes();
            bytes[i * 8..(i + 1) * 8].copy_from_slice(&limb_bytes);
        }

        bytes
    }

    /// Creates a field element from a 32-byte array in little-endian format.
    ///
    /// Returns `None` if the bytes represent a value >= p.
    /// This function performs constant-time validation.
    pub fn from_bytes(bytes: &[u8; 32]) -> CtOption<Self> {
        let mut limbs = [0u64; 4];

        // Convert from little-endian bytes to little-endian limbs
        for i in 0..4 {
            limbs[i] = u64::from_le_bytes([
                bytes[i * 8],
                bytes[i * 8 + 1],
                bytes[i * 8 + 2],
                bytes[i * 8 + 3],
                bytes[i * 8 + 4],
                bytes[i * 8 + 5],
                bytes[i * 8 + 6],
                bytes[i * 8 + 7],
            ]);
        }

        // Check if the value is less than p in constant time
        let mut is_less = Choice::from(0u8);
        let mut is_equal = Choice::from(1u8);

        for i in (0..4).rev() {
            let lt = Choice::from((limbs[i] < P[i]) as u8);
            let eq = Choice::from((limbs[i] == P[i]) as u8);
            let gt = Choice::from((limbs[i] > P[i]) as u8);

            is_less |= is_equal & lt;
            is_equal &= eq;

            // If we find a greater limb, the value is definitely >= p
            if bool::from(gt) {
                return CtOption::new(Self::zero(), Choice::from(0u8));
            }
        }

        // Value is valid if it's less than p (not equal to p)
        let is_valid = is_less;
        CtOption::new(Self(limbs), is_valid)
    }

    /// Computes the square root of this field element using the Tonelli-Shanks algorithm.
    ///
    /// For Ed25519, p ≡ 5 (mod 8), so we can use an optimized algorithm.
    /// Returns `None` if this element is not a quadratic residue.
    pub fn sqrt(&self) -> CtOption<Self> {
        // For p ≡ 5 (mod 8), we can use the formula:
        // If a^((p-1)/4) ≡ 1 (mod p), then sqrt(a) = a^((p+3)/8)
        // If a^((p-1)/4) ≡ -1 (mod p), then sqrt(a) = a^((p+3)/8) * sqrt(-1)

        // First check if this is a quadratic residue
        // Compute a^((p-1)/2) using Legendre symbol
        let p_minus_1_div_2 = [
            0x7FFF_FFFF_FFFF_FFF6, // (p-1)/2 low bits
            0xFFFF_FFFF_FFFF_FFFF,
            0xFFFF_FFFF_FFFF_FFFF,
            0x3FFF_FFFF_FFFF_FFFF,
        ];

        let legendre = self.pow(&p_minus_1_div_2);
        let is_qr = legendre.ct_eq(&Self::one()) | legendre.ct_eq(&Self::zero());

        if !bool::from(is_qr) {
            return CtOption::new(Self::zero(), Choice::from(0u8));
        }

        // Compute a^((p+3)/8)
        let p_plus_3_div_8 = [
            0x1FFF_FFFF_FFFF_FFFF, // (p+3)/8 low bits
            0xFFFF_FFFF_FFFF_FFFF,
            0xFFFF_FFFF_FFFF_FFFF,
            0x0FFF_FFFF_FFFF_FFFF,
        ];

        let candidate = self.pow(&p_plus_3_div_8);

        // Check if candidate^2 = self
        let candidate_squared = candidate.square();
        let is_correct = candidate_squared.ct_eq(self);

        // If not correct, multiply by sqrt(-1)
        let sqrt_minus_one = Self::from_raw(SQRT_M1);
        let alt_candidate = candidate * sqrt_minus_one;
        let alt_squared = alt_candidate.square();
        let alt_is_correct = alt_squared.ct_eq(self);

        let result = Self::conditional_select(&candidate, &alt_candidate, alt_is_correct);
        let is_valid = is_correct | alt_is_correct;

        CtOption::new(result, is_valid)
    }

    /// Computes the power of this field element using binary exponentiation.
    ///
    /// This function implements constant-time exponentiation using the square-and-multiply
    /// algorithm. The exponent is processed bit by bit to ensure constant-time execution.
    pub fn pow(&self, exp: &[u64; 4]) -> Self {
        let mut result = Self::one();
        let mut base = *self;

        // Process each limb of the exponent
        for &limb in exp.iter() {
            // Process each bit of the current limb
            for i in 0..64 {
                let bit = (limb >> i) & 1;
                let bit_choice = Choice::from(bit as u8);

                // Conditionally multiply result by base if bit is 1
                let new_result = result * base;
                result = Self::conditional_select(&result, &new_result, bit_choice);

                // Square the base for the next bit
                base = base.square();
            }
        }

        result
    }
}

// ================================================================================================
// Trait Implementations for FieldElement
// ================================================================================================

impl ConditionallySelectable for FieldElement {
    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
        Self([
            u64::conditional_select(&a.0[0], &b.0[0], choice),
            u64::conditional_select(&a.0[1], &b.0[1], choice),
            u64::conditional_select(&a.0[2], &b.0[2], choice),
            u64::conditional_select(&a.0[3], &b.0[3], choice),
        ])
    }
}

impl ConstantTimeEq for FieldElement {
    fn ct_eq(&self, other: &Self) -> Choice {
        self.0[0].ct_eq(&other.0[0])
            & self.0[1].ct_eq(&other.0[1])
            & self.0[2].ct_eq(&other.0[2])
            & self.0[3].ct_eq(&other.0[3])
    }
}

impl Add for FieldElement {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        let mut result = [0u64; 4];
        let mut carry = 0u64;

        // Add corresponding limbs with carry propagation
        for i in 0..4 {
            let sum = (self.0[i] as u128) + (rhs.0[i] as u128) + (carry as u128);
            result[i] = sum as u64;
            carry = (sum >> 64) as u64;
        }

        // Handle the final carry by adding it * 19 (since 2^256 ≡ 38 ≡ 2*19 (mod p))
        if carry > 0 {
            let mut extra_carry = carry * 19;
            for i in 0..4 {
                let sum = (result[i] as u128) + (extra_carry as u128);
                result[i] = sum as u64;
                extra_carry = (sum >> 64) as u64;
            }
        }

        // Create result and reduce to ensure canonical form
        let mut output = Self(result);
        output.reduce();

        output
    }
}

impl Sub for FieldElement {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        // Compute self - rhs in constant time
        // If self < rhs, we need to add p to avoid underflow

        let mut result = [0u64; 4];
        let mut borrow = 0u64;

        // Perform subtraction with borrow
        for i in 0..4 {
            let (diff1, b1) = self.0[i].overflowing_sub(rhs.0[i]);
            let (diff2, b2) = diff1.overflowing_sub(borrow);
            result[i] = diff2;
            borrow = (b1 as u64) + (b2 as u64);
        }

        // If there was a borrow, add p to the result
        if borrow > 0 {
            let mut carry = 0u64;
            for i in 0..4 {
                let sum = (result[i] as u128) + (P[i] as u128) + (carry as u128);
                result[i] = sum as u64;
                carry = (sum >> 64) as u64;
            }
        }

        Self(result)
    }
}

impl Mul for FieldElement {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        // Use schoolbook multiplication to compute the full 512-bit product
        let mut product = [0u64; 8];

        // Compute partial products
        for i in 0..4 {
            let mut carry = 0u64;
            for j in 0..4 {
                let prod = (self.0[i] as u128) * (rhs.0[j] as u128)
                         + (product[i + j] as u128)
                         + (carry as u128);
                product[i + j] = prod as u64;
                carry = (prod >> 64) as u64;
            }
            product[i + 4] = carry;
        }

        // Reduce using the optimized wide reduction
        Self::reduce_wide(&product)
    }
}

impl Neg for FieldElement {
    type Output = Self;

    fn neg(self) -> Self {
        // Compute p - self in constant time
        // Special case: if self is zero, return zero
        let is_zero = self.is_zero();

        let mut result = [0u64; 4];
        let mut borrow = 0u64;

        // Compute p - self
        for i in 0..4 {
            let (diff1, b1) = P[i].overflowing_sub(self.0[i]);
            let (diff2, b2) = diff1.overflowing_sub(borrow);
            result[i] = diff2;
            borrow = (b1 as u64) + (b2 as u64);
        }

        // If self was zero, return zero instead of p
        let neg_result = Self(result);
        Self::conditional_select(&neg_result, &Self::zero(), is_zero)
    }
}

impl AddAssign for FieldElement {
    fn add_assign(&mut self, rhs: Self) {
        *self = *self + rhs;
    }
}

impl SubAssign for FieldElement {
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

impl MulAssign for FieldElement {
    fn mul_assign(&mut self, rhs: Self) {
        *self = *self * rhs;
    }
}

impl forge_ec_core::FieldElement for FieldElement {
    fn zero() -> Self {
        Self([0, 0, 0, 0])
    }

    fn one() -> Self {
        Self([1, 0, 0, 0])
    }

    fn is_zero(&self) -> Choice {
        self.ct_eq(&Self::zero())
    }

    fn invert(&self) -> CtOption<Self> {
        // Use Fermat's Little Theorem: a^(p-2) ≡ a^(-1) (mod p)
        // For Ed25519, p = 2^255 - 19, so p-2 = 2^255 - 21

        let is_zero = self.is_zero();

        // Compute p-2 = 2^255 - 21
        let p_minus_2 = [
            0xFFFF_FFFF_FFFF_FFEB, // (2^255 - 21) mod 2^64
            0xFFFF_FFFF_FFFF_FFFF,
            0xFFFF_FFFF_FFFF_FFFF,
            0x7FFF_FFFF_FFFF_FFFF,
        ];

        let inv = self.pow(&p_minus_2);

        // Return None if the input was zero
        CtOption::new(inv, !is_zero)
    }

    fn square(&self) -> Self {
        *self * *self
    }

    fn pow(&self, exp: &[u64]) -> Self {
        // Convert slice to fixed-size array for our internal pow method
        let mut exp_array = [0u64; 4];
        let len = core::cmp::min(exp.len(), 4);
        exp_array[..len].copy_from_slice(&exp[..len]);

        self.pow(&exp_array)
    }

    fn to_bytes(&self) -> [u8; 32] {
        // Use our optimized to_bytes method
        self.to_bytes()
    }

    fn from_bytes(bytes: &[u8]) -> CtOption<Self> {
        if bytes.len() != 32 {
            return CtOption::new(Self::zero(), Choice::from(0u8));
        }

        let mut bytes_array = [0u8; 32];
        bytes_array.copy_from_slice(bytes);
        Self::from_bytes(&bytes_array)
    }

    fn random(mut rng: impl rand_core::RngCore) -> Self {
        loop {
            // Generate random bytes
            let mut bytes = [0u8; 32];
            rng.fill_bytes(&mut bytes);

            // Try to create a field element from these bytes
            if let Some(element) = Self::from_bytes(&bytes).into() {
                return element;
            }
            // If the bytes represent a value >= p, try again
        }
    }

    fn sqrt(&self) -> CtOption<Self> {
        // Use our optimized sqrt method
        self.sqrt()
    }
}

impl Zeroize for FieldElement {
    fn zeroize(&mut self) {
        self.0.zeroize();
    }
}

// ================================================================================================
// Scalar Implementation
// ================================================================================================

/// A scalar value in the Ed25519 scalar field.
///
/// This type represents elements of the scalar field used for Ed25519 operations.
/// The scalar field has order l = 2^252 + 27742317777372353535851937790883648493.
/// All operations are implemented to be constant-time when operating on secret data.
///
/// # Internal Representation
///
/// Scalars are stored as four 64-bit limbs in little-endian order, representing
/// a 256-bit integer. The value is always kept in the range [0, l-1] through reduction.
///
/// # Security Considerations
///
/// - All arithmetic operations are constant-time
/// - Memory is automatically zeroized when the scalar is dropped
/// - No secret-dependent branches or memory accesses
/// - Implements RFC 6979 for deterministic nonce generation
///
/// # Examples
///
/// ```rust
/// use forge_ec_curves::ed25519::Scalar;
/// use forge_ec_core::{FieldElement, Scalar as CoreScalar};
/// use rand_core::OsRng;
///
/// let mut rng = OsRng;
/// let a = <Scalar as CoreScalar>::random(&mut rng);
/// let b = Scalar::from(42u64);
/// let c = a + b;
/// assert!(!bool::from(c.is_zero()));
/// ```
#[derive(Copy, Clone, Debug, Default)]
pub struct Scalar([u64; 4]);

impl Scalar {
    /// Creates a new scalar from raw limbs.
    ///
    /// # Security Note
    ///
    /// The caller must ensure that the raw limbs represent a value less than l.
    /// This function does not perform reduction.
    pub const fn from_raw(raw: [u64; 4]) -> Self {
        Self(raw)
    }

    /// Returns the raw limbs of this scalar.
    ///
    /// The limbs are returned in little-endian order.
    pub const fn to_raw(&self) -> [u64; 4] {
        self.0
    }

    /// Creates a new scalar from a u64 value.
    ///
    /// This is equivalent to `Scalar::from_raw([value, 0, 0, 0])`.
    pub const fn from_u64(value: u64) -> Self {
        Self([value, 0, 0, 0])
    }

    /// Performs constant-time scalar reduction modulo l.
    ///
    /// This function reduces the scalar to the canonical range [0, l-1].
    /// The implementation is constant-time to prevent timing attacks.
    fn reduce(&mut self) {
        // Check if the value is >= l and subtract l if necessary
        let mut diff = [0u64; 4];
        let mut borrow = 0u64;

        // Compute self - l
        for i in 0..4 {
            let (d1, b1) = self.0[i].overflowing_sub(L[i]);
            let (d2, b2) = d1.overflowing_sub(borrow);
            diff[i] = d2;
            borrow = (b1 as u64) + (b2 as u64);
        }

        // If no borrow occurred, self >= l, so use the difference
        let use_diff = Choice::from((borrow == 0) as u8);
        for i in 0..4 {
            self.0[i] = u64::conditional_select(&self.0[i], &diff[i], use_diff);
        }
    }

    /// Converts this scalar to a 32-byte array in little-endian format.
    ///
    /// This function ensures the scalar is in canonical form before conversion.
    pub fn to_bytes(&self) -> [u8; 32] {
        // Ensure the scalar is in canonical form
        let mut canonical = *self;
        canonical.reduce();

        let mut bytes = [0u8; 32];

        // Convert from little-endian limbs to little-endian bytes
        for i in 0..4 {
            let limb_bytes = canonical.0[i].to_le_bytes();
            bytes[i * 8..(i + 1) * 8].copy_from_slice(&limb_bytes);
        }

        bytes
    }

    /// Creates a scalar from a 32-byte array in little-endian format.
    ///
    /// Returns `None` if the bytes represent a value >= l.
    /// This function performs constant-time validation.
    pub fn from_bytes(bytes: &[u8; 32]) -> CtOption<Self> {
        let mut limbs = [0u64; 4];

        // Convert from little-endian bytes to little-endian limbs
        for i in 0..4 {
            limbs[i] = u64::from_le_bytes([
                bytes[i * 8],
                bytes[i * 8 + 1],
                bytes[i * 8 + 2],
                bytes[i * 8 + 3],
                bytes[i * 8 + 4],
                bytes[i * 8 + 5],
                bytes[i * 8 + 6],
                bytes[i * 8 + 7],
            ]);
        }

        // Check if the value is less than l in constant time
        let mut is_less = Choice::from(0u8);
        let mut is_equal = Choice::from(1u8);

        for i in (0..4).rev() {
            let lt = Choice::from((limbs[i] < L[i]) as u8);
            let eq = Choice::from((limbs[i] == L[i]) as u8);
            let gt = Choice::from((limbs[i] > L[i]) as u8);

            is_less |= is_equal & lt;
            is_equal &= eq;

            // If we find a greater limb, the value is definitely >= l
            if bool::from(gt) {
                return CtOption::new(Self::zero(), Choice::from(0u8));
            }
        }

        // Value is valid if it's less than l (not equal to l)
        let is_valid = is_less;
        CtOption::new(Self(limbs), is_valid)
    }

    /// Computes the power of this scalar using binary exponentiation.
    ///
    /// This function implements constant-time exponentiation using the square-and-multiply
    /// algorithm. The exponent is processed bit by bit to ensure constant-time execution.
    pub fn pow(&self, exp: &[u64; 4]) -> Self {
        let mut result = Self::one();
        let mut base = *self;

        // Process each limb of the exponent
        for &limb in exp.iter() {
            // Process each bit of the current limb
            for i in 0..64 {
                let bit = (limb >> i) & 1;
                let bit_choice = Choice::from(bit as u8);

                // Conditionally multiply result by base if bit is 1
                let new_result = result * base;
                result = Self::conditional_select(&result, &new_result, bit_choice);

                // Square the base for the next bit
                base = base.square();
            }
        }

        result
    }
}

// ================================================================================================
// Trait Implementations for Scalar
// ================================================================================================

impl ConditionallySelectable for Scalar {
    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
        Self([
            u64::conditional_select(&a.0[0], &b.0[0], choice),
            u64::conditional_select(&a.0[1], &b.0[1], choice),
            u64::conditional_select(&a.0[2], &b.0[2], choice),
            u64::conditional_select(&a.0[3], &b.0[3], choice),
        ])
    }
}

impl ConstantTimeEq for Scalar {
    fn ct_eq(&self, other: &Self) -> Choice {
        self.0[0].ct_eq(&other.0[0])
            & self.0[1].ct_eq(&other.0[1])
            & self.0[2].ct_eq(&other.0[2])
            & self.0[3].ct_eq(&other.0[3])
    }
}

impl forge_ec_core::FieldElement for Scalar {
    fn zero() -> Self {
        Self([0, 0, 0, 0])
    }

    fn one() -> Self {
        Self([1, 0, 0, 0])
    }

    fn is_zero(&self) -> Choice {
        self.ct_eq(&Self::zero())
    }

    fn invert(&self) -> CtOption<Self> {
        // Use Fermat's Little Theorem: a^(l-2) ≡ a^(-1) (mod l)
        // For Ed25519, l = 2^252 + 27742317777372353535851937790883648493

        let is_zero = self.is_zero();

        // Compute l-2
        let l_minus_2 = [
            0x5812_631A_5CF5_D3EB, // (l-2) mod 2^64
            0x14DE_F9DE_A2F7_9CD6,
            0x0000_0000_0000_0000,
            0x1000_0000_0000_0000,
        ];

        let inv = self.pow(&l_minus_2);

        // Return None if the input was zero
        CtOption::new(inv, !is_zero)
    }

    fn square(&self) -> Self {
        *self * *self
    }

    fn pow(&self, exp: &[u64]) -> Self {
        // Convert slice to fixed-size array for our internal pow method
        let mut exp_array = [0u64; 4];
        let len = core::cmp::min(exp.len(), 4);
        exp_array[..len].copy_from_slice(&exp[..len]);

        self.pow(&exp_array)
    }

    fn to_bytes(&self) -> [u8; 32] {
        self.to_bytes()
    }

    fn from_bytes(bytes: &[u8]) -> CtOption<Self> {
        if bytes.len() != 32 {
            return CtOption::new(Self::zero(), Choice::from(0u8));
        }

        let mut bytes_array = [0u8; 32];
        bytes_array.copy_from_slice(bytes);
        Self::from_bytes(&bytes_array)
    }

    fn random(mut rng: impl rand_core::RngCore) -> Self {
        // For Ed25519, we can use a simpler approach since l ≈ 2^252
        // Generate 32 random bytes and reduce modulo l
        let mut bytes = [0u8; 32];
        rng.fill_bytes(&mut bytes);

        // Convert to limbs
        let mut limbs = [0u64; 4];
        for i in 0..4 {
            limbs[i] = u64::from_le_bytes([
                bytes[i * 8],
                bytes[i * 8 + 1],
                bytes[i * 8 + 2],
                bytes[i * 8 + 3],
                bytes[i * 8 + 4],
                bytes[i * 8 + 5],
                bytes[i * 8 + 6],
                bytes[i * 8 + 7],
            ]);
        }

        // Create scalar and reduce
        let mut result = Self(limbs);
        result.reduce();
        result
    }

    fn sqrt(&self) -> CtOption<Self> {
        // Square roots in the scalar field are rarely needed for Ed25519
        // Return None for all inputs
        CtOption::new(Self::zero(), Choice::from(0u8))
    }
}

impl Zeroize for Scalar {
    fn zeroize(&mut self) {
        self.0.zeroize();
    }
}

impl forge_ec_core::Scalar for Scalar {
    const BITS: usize = 252;

    fn random(rng: impl rand_core::RngCore) -> Self {
        // Use the implementation from FieldElement
        <Self as forge_ec_core::FieldElement>::random(rng)
    }

    fn from_rfc6979(msg: &[u8], key: &[u8], extra: &[u8]) -> Self {
        // Implementation of RFC6979 deterministic scalar generation
        // This follows the algorithm described in RFC6979 to generate a deterministic
        // nonce (k) for use in digital signatures

        // Step 1: Convert the private key to a fixed-length byte array
        let mut private_key_bytes = [0u8; 32];
        let key_len = core::cmp::min(key.len(), 32);
        private_key_bytes[..key_len].copy_from_slice(&key[..key_len]);

        // Step 2: Compute h1 = H(message) using SHA-512 (standard for Ed25519)
        use sha2::{Digest, Sha512};
        let mut h1 = Sha512::new();
        h1.update(msg);
        let h1 = h1.finalize();

        // Step 3: Prepare the input for HMAC
        // 3.1: Convert the message hash to a byte array of the same length as the private key
        let mut h1_bytes = [0u8; 64]; // SHA-512 produces 64 bytes
        h1_bytes.copy_from_slice(h1.as_slice());

        // 3.2: Get the byte length of the curve order (qlen)
        let qlen = Self::BITS;
        let rlen = (qlen + 7) / 8; // rlen is the byte length of the curve order

        // 3.3: Initialize variables
        let mut v = [0x01u8; 64]; // V = 0x01 0x01 0x01 ... (same length as hash output)
        let mut k = [0x00u8; 64]; // K = 0x00 0x00 0x00 ... (same length as hash output)

        // Use zeroize::Zeroize for secure cleanup
        use zeroize::Zeroize;

        // Scope for HMAC operations to ensure proper cleanup
        let scalar = {
            // 3.4: Initialize HMAC key with K
            use hmac::{Hmac, Mac};
            type HmacSha512 = Hmac<Sha512>;

            // 3.5: K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1))
            let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
            hmac_key.update(&v);
            hmac_key.update(&[0x00]);
            hmac_key.update(&private_key_bytes);
            hmac_key.update(&h1_bytes[..32]); // Use first 32 bytes of h1
            if !extra.is_empty() {
                hmac_key.update(extra);
            }
            let result = hmac_key.finalize();
            k.copy_from_slice(result.into_bytes().as_slice());

            // 3.6: V = HMAC_K(V)
            let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
            hmac_key.update(&v);
            let result = hmac_key.finalize();
            v.copy_from_slice(result.into_bytes().as_slice());

            // 3.7: K = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))
            let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
            hmac_key.update(&v);
            hmac_key.update(&[0x01]);
            hmac_key.update(&private_key_bytes);
            hmac_key.update(&h1_bytes[..32]); // Use first 32 bytes of h1
            if !extra.is_empty() {
                hmac_key.update(extra);
            }
            let result = hmac_key.finalize();
            k.copy_from_slice(result.into_bytes().as_slice());

            // 3.8: V = HMAC_K(V)
            let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
            hmac_key.update(&v);
            let result = hmac_key.finalize();
            v.copy_from_slice(result.into_bytes().as_slice());

            // 3.9: Generate k
            let mut t = [0u8; 32];
            let mut generated = false;
            let mut scalar_option = <Self as forge_ec_core::FieldElement>::from_bytes(&[0u8; 32]);

            while !generated {
                // 3.9.1: T = empty
                let mut toff = 0;

                // 3.9.2: While tlen < qlen, do V = HMAC_K(V), T = T || V
                while toff < rlen {
                    let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
                    hmac_key.update(&v);
                    let result = hmac_key.finalize();
                    v.copy_from_slice(result.into_bytes().as_slice());

                    let remaining = rlen - toff;
                    let to_copy = core::cmp::min(remaining, v.len());
                    t[toff..toff + to_copy].copy_from_slice(&v[..to_copy]);
                    toff += to_copy;
                }

                // 3.9.3: Convert T to a scalar by reducing modulo l
                // Instead of using from_bytes validation, just reduce the value
                let mut limbs = [0u64; 4];
                for i in 0..4 {
                    if i * 8 < t.len() {
                        let end = core::cmp::min((i + 1) * 8, t.len());
                        let mut bytes = [0u8; 8];
                        bytes[..end - i * 8].copy_from_slice(&t[i * 8..end]);
                        limbs[i] = u64::from_le_bytes(bytes);
                    }
                }

                let mut candidate = Self(limbs);
                candidate.reduce();

                // 3.9.4: Check if the scalar is valid (not zero)
                if !bool::from(candidate.is_zero()) {
                    scalar_option = CtOption::new(candidate, Choice::from(1u8));
                    generated = true;
                }

                // 3.9.5: If not valid, update K and V and try again
                if !generated {
                    let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
                    hmac_key.update(&v);
                    hmac_key.update(&[0x00]);
                    let result = hmac_key.finalize();
                    k.copy_from_slice(result.into_bytes().as_slice());

                    let mut hmac_key = HmacSha512::new_from_slice(&k).unwrap();
                    hmac_key.update(&v);
                    let result = hmac_key.finalize();
                    v.copy_from_slice(result.into_bytes().as_slice());
                }

                // Zeroize t after each iteration for security
                if !generated {
                    t.zeroize();
                }
            }

            // Extract the scalar before zeroizing everything
            let scalar = scalar_option.unwrap();

            // Zeroize t
            t.zeroize();

            scalar
        };

        // Zeroize all sensitive data before returning
        v.zeroize();
        k.zeroize();
        h1_bytes.zeroize();
        private_key_bytes.zeroize();

        scalar
    }

    fn from_bytes(bytes: &[u8]) -> CtOption<Self> {
        if bytes.len() != 32 {
            return CtOption::new(Self::zero(), Choice::from(0));
        }

        let mut bytes_array = [0u8; 32];
        bytes_array.copy_from_slice(&bytes[0..32]);

        // Convert from big-endian bytes to little-endian limbs
        let mut limbs = [0u64; 4];
        for i in 0..4 {
            for j in 0..8 {
                limbs[i] |= (bytes_array[31 - (i * 8 + j)] as u64) << (j * 8);
            }
        }

        // Check if the value is less than the order (placeholder)
        let is_valid = true;

        CtOption::new(Self(limbs), Choice::from(if is_valid { 1 } else { 0 }))
    }

    fn to_bytes(&self) -> [u8; 32] {
        // Convert to bytes manually
        let mut bytes = [0u8; 32];

        // Convert from little-endian limbs to big-endian bytes
        for i in 0..4 {
            for j in 0..8 {
                bytes[31 - (i * 8 + j)] = ((self.0[i] >> (j * 8)) & 0xFF) as u8;
            }
        }

        bytes
    }

    fn get_order() -> Self {
        // Return the order of the Ed25519 curve
        // l = 2^252 + 27742317777372353535851937790883648493
        Self(L)
    }
}

impl From<u64> for Scalar {
    fn from(value: u64) -> Self {
        let mut result = Self::zero();
        result.0[0] = value;
        result
    }
}

impl Add for Scalar {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        // Add the limbs with carry propagation
        let mut result = Self::zero();
        let mut carry = 0u64;

        for i in 0..4 {
            // Add the limbs and the carry
            let sum = self.0[i] as u128 + rhs.0[i] as u128 + carry as u128;
            result.0[i] = sum as u64;
            carry = (sum >> 64) as u64;
        }

        // The scalar field order L = 2^252 + 27742317777372353535851937790883648493
        const ORDER: [u64; 4] = [
            0x5812_631A_5CF5_D3ED,
            0x14DE_F9DE_A2F7_9CD6,
            0x0000_0000_0000_0000,
            0x1000_0000_0000_0000,
        ];

        // Check if the result is greater than or equal to the order
        let mut is_greater_or_equal = true;
        for i in (0..4).rev() {
            if result.0[i] < ORDER[i] {
                is_greater_or_equal = false;
                break;
            } else if result.0[i] > ORDER[i] {
                break;
            }
        }

        // If the result is greater than or equal to the order, subtract the order
        if is_greater_or_equal {
            let mut borrow = 0u64;
            for i in 0..4 {
                let diff = result.0[i] as i128 - ORDER[i] as i128 - borrow as i128;
                result.0[i] = diff as u64;
                borrow = if diff < 0 { 1 } else { 0 };
            }
        }

        result
    }
}

impl Sub for Scalar {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        // Subtraction in a finite field is defined as: a - b = a + (-b)
        // where -b is the additive inverse of b

        // Compute the negation of rhs
        let neg_rhs = -rhs;

        // Add self and the negation of rhs
        self + neg_rhs
    }
}

impl Mul for Scalar {
    type Output = Self;

    fn mul(self, rhs: Self) -> Self {
        // Implement schoolbook multiplication with 128-bit intermediate products
        // This is a simple but effective approach for 256-bit field elements

        // Temporary storage for the product
        let mut product = [0u128; 8];

        // Compute the full 512-bit product
        for i in 0..4 {
            for j in 0..4 {
                product[i + j] += self.0[i] as u128 * rhs.0[j] as u128;
            }
        }

        // Handle the carries
        let mut carry = 0u128;
        for i in 0..8 {
            product[i] += carry;
            carry = product[i] >> 64;
            product[i] &= 0xFFFF_FFFF_FFFF_FFFF;
        }

        // Now we need to reduce modulo the order L
        // The scalar field order L = 2^252 + 27742317777372353535851937790883648493
        const ORDER: [u64; 4] = [
            0x5812_631A_5CF5_D3ED,
            0x14DE_F9DE_A2F7_9CD6,
            0x0000_0000_0000_0000,
            0x1000_0000_0000_0000,
        ];

        // Convert the product to a scalar
        let mut result = Self::zero();
        for i in 0..4 {
            result.0[i] = product[i] as u64;
        }

        // Perform modular reduction
        // We'll use Barrett reduction, which is a fast method for modular reduction
        // when the modulus is fixed

        // First, check if the result is already less than the order
        // This variable will be set based on comparison results
        // Using #[allow(unused_assignments)] to suppress the warning
        #[allow(unused_assignments)]
        let mut is_greater_or_equal = false;

        // Check if the high 256 bits are non-zero
        if product[4] != 0 || product[5] != 0 || product[6] != 0 || product[7] != 0 {
            is_greater_or_equal = true;
        } else {
            // Check if the low 256 bits are greater than or equal to the order
            is_greater_or_equal = true;
            for i in (0..4).rev() {
                if result.0[i] < ORDER[i] {
                    is_greater_or_equal = false;
                    break;
                } else if result.0[i] > ORDER[i] {
                    break;
                }
            }
        }

        // If the result is greater than or equal to the order, we need to reduce it
        if is_greater_or_equal {
            // We'll use a simple approach: repeatedly subtract the order until the result is less than the order
            // This is not the most efficient approach, but it's simple and works for all cases

            // First, handle the high 256 bits
            if product[4] != 0 || product[5] != 0 || product[6] != 0 || product[7] != 0 {
                // Multiply the high 256 bits by 2^256 mod L
                // 2^256 mod L = 2^256 - L = 2^256 - (2^252 + 27742317777372353535851937790883648493)
                //              = 2^256 - 2^252 - 27742317777372353535851937790883648493
                //              = 2^252 * (2^4 - 1) - 27742317777372353535851937790883648493
                //              = 2^252 * 15 - 27742317777372353535851937790883648493

                // This is a complex calculation, so we'll use a simpler approach:
                // Repeatedly subtract the order until the result is less than the order

                // Convert the high 256 bits to a scalar
                let mut high_bits = Self::zero();
                for i in 0..4 {
                    high_bits.0[i] = product[i + 4] as u64;
                }

                // Multiply by 2^256 mod L
                // This is equivalent to shifting left by 256 bits and then reducing modulo L
                // Since we're working with 256-bit scalars, this is just the value itself

                // Now add the high bits (multiplied by 2^256 mod L) to the result
                // We'll do this by repeatedly adding the high bits and reducing modulo L
                for _ in 0..256 {
                    result += high_bits;
                }
            }

            // Now the result is less than 2*L, so we just need to subtract L if necessary
            let mut is_greater_or_equal = true;
            for i in (0..4).rev() {
                if result.0[i] < ORDER[i] {
                    is_greater_or_equal = false;
                    break;
                } else if result.0[i] > ORDER[i] {
                    break;
                }
            }

            if is_greater_or_equal {
                let mut borrow = 0u64;
                for i in 0..4 {
                    let diff = result.0[i] as i128 - ORDER[i] as i128 - borrow as i128;
                    result.0[i] = diff as u64;
                    borrow = if diff < 0 { 1 } else { 0 };
                }
            }
        }

        result
    }
}

impl<'a> Mul<&'a Scalar> for Scalar {
    type Output = Scalar;

    fn mul(self, rhs: &'a Scalar) -> Scalar {
        self * *rhs
    }
}

impl Neg for Scalar {
    type Output = Self;

    fn neg(self) -> Self {
        // Negation in a finite field is defined as: -a = p - a
        // where p is the field order

        // If self is zero, the result is also zero
        if self.is_zero().unwrap_u8() == 1 {
            return self;
        }

        // The scalar field order L = 2^252 + 27742317777372353535851937790883648493
        const ORDER: [u64; 4] = [
            0x5812_631A_5CF5_D3ED,
            0x14DE_F9DE_A2F7_9CD6,
            0x0000_0000_0000_0000,
            0x1000_0000_0000_0000,
        ];

        // Compute L - self
        let mut result = Self::zero();
        let mut borrow = 0u64;

        for i in 0..4 {
            let diff = ORDER[i] as i128 - self.0[i] as i128 - borrow as i128;
            result.0[i] = diff as u64;
            borrow = if diff < 0 { 1 } else { 0 };
        }

        // No need to reduce here as the result is already in the range [0, L-1]
        result
    }
}

impl AddAssign for Scalar {
    fn add_assign(&mut self, rhs: Self) {
        *self = *self + rhs;
    }
}

impl SubAssign for Scalar {
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

impl MulAssign for Scalar {
    fn mul_assign(&mut self, rhs: Self) {
        *self = *self * rhs;
    }
}



/// A point in extended coordinates on the Ed25519 curve.
#[derive(Copy, Clone, Debug, Default)]
pub struct ExtendedPoint {
    x: FieldElement,
    y: FieldElement,
    z: FieldElement,
    t: FieldElement,
}

/// A point in affine coordinates on the Ed25519 curve.
#[derive(Copy, Clone, Debug)]
pub struct AffinePoint {
    x: FieldElement,
    y: FieldElement,
    infinity: Choice,
}

impl Default for AffinePoint {
    fn default() -> Self {
        Self { x: FieldElement::default(), y: FieldElement::default(), infinity: Choice::from(0) }
    }
}

impl PointAffine for AffinePoint {
    type Field = FieldElement;

    fn x(&self) -> Self::Field {
        self.x
    }

    fn y(&self) -> Self::Field {
        self.y
    }

    fn new(x: Self::Field, y: Self::Field) -> CtOption<Self> {
        // Check if the point satisfies the curve equation: -x^2 + y^2 = 1 + d*x^2*y^2
        let x2 = x.square();
        let y2 = y.square();
        let x2y2 = x2 * y2;

        // Ed25519 curve parameter d = -121665/121666
        let d = FieldElement::from_raw(D);

        // Compute left side: -x^2 + y^2
        let neg_x2 = -x2;
        let lhs = neg_x2 + y2;

        // Compute right side: 1 + d*x^2*y^2
        let one = FieldElement::one();
        let d_x2y2 = d * x2y2;
        let rhs = one + d_x2y2;

        // Check if lhs == rhs
        let is_on_curve = lhs.ct_eq(&rhs);

        CtOption::new(Self { x, y, infinity: Choice::from(0) }, is_on_curve)
    }

    fn is_identity(&self) -> Choice {
        self.infinity
    }

    fn to_bytes(&self) -> [u8; 33] {
        let mut bytes = [0u8; 33];

        if self.infinity.unwrap_u8() == 1 {
            // Point at infinity is represented by a single byte 0x00
            bytes[0] = 0x00;
        } else {
            // Compressed format: 0x02 for even y, 0x03 for odd y
            let y_bytes = self.y.to_bytes();
            let y_is_odd = (y_bytes[31] & 1) == 1;

            bytes[0] = if y_is_odd { 0x03 } else { 0x02 };

            // Copy x-coordinate
            let x_bytes = self.x.to_bytes();
            bytes[1..33].copy_from_slice(&x_bytes);
        }

        bytes
    }

    fn from_bytes(bytes: &[u8; 33]) -> CtOption<Self> {
        if bytes[0] == 0x00 {
            // Point at infinity
            return CtOption::new(
                Self {
                    x: FieldElement::zero(),
                    y: FieldElement::zero(),
                    infinity: Choice::from(1),
                },
                Choice::from(1),
            );
        }

        if bytes[0] != 0x02 && bytes[0] != 0x03 {
            // Invalid prefix
            return CtOption::new(Self::default(), Choice::from(0));
        }

        // Extract the x-coordinate
        let mut x_bytes = [0u8; 32];
        x_bytes.copy_from_slice(&bytes[1..33]);

        let x_opt = FieldElement::from_bytes(&x_bytes);
        if x_opt.is_none().unwrap_u8() == 1 {
            return CtOption::new(Self::default(), Choice::from(0));
        }
        let x = x_opt.unwrap();

        // Compute y^2 = x^3 + ax^2 + x (Ed25519 curve equation)
        let x2 = x.square();
        let x3 = x2 * x;

        // Ed25519 curve parameters
        let a = FieldElement::from_raw([0x7FFF_FFDA, 0, 0, 0]);

        let y2 = x3 + a * x2 + x;

        // Compute the square root of y^2
        let y_opt = y2.sqrt();
        if y_opt.is_none().unwrap_u8() == 1 {
            return CtOption::new(Self::default(), Choice::from(0));
        }
        let mut y = y_opt.unwrap();

        // Check if we need to negate y based on the prefix
        let y_bytes = y.to_bytes();
        let y_is_odd = (y_bytes[31] & 1) == 1;
        let y_should_be_odd = bytes[0] == 0x03;

        if y_is_odd != y_should_be_odd {
            y = -y;
        }

        // Create the point
        CtOption::new(Self { x, y, infinity: Choice::from(0) }, Choice::from(1))
    }

    fn to_bytes_with_format(&self, format: forge_ec_core::PointFormat) -> Vec<u8> {
        if self.infinity.unwrap_u8() == 1 {
            // Point at infinity is represented by a single byte 0x00
            return vec![0x00];
        }

        match format {
            forge_ec_core::PointFormat::Compressed => {
                let mut bytes = Vec::with_capacity(33);

                // Compressed encoding: 0x02 for even y, 0x03 for odd y
                let y_bytes = self.y.to_bytes();
                let y_is_odd = (y_bytes[31] & 1) == 1;

                bytes.push(if y_is_odd { 0x03 } else { 0x02 });

                // Copy x-coordinate
                let x_bytes = self.x.to_bytes();
                bytes.extend_from_slice(&x_bytes);

                bytes
            }
            forge_ec_core::PointFormat::Uncompressed => {
                let mut bytes = Vec::with_capacity(65);

                // Uncompressed encoding: 0x04 followed by x and y coordinates
                bytes.push(0x04);

                // Copy x-coordinate
                let x_bytes = self.x.to_bytes();
                bytes.extend_from_slice(&x_bytes);

                // Copy y-coordinate
                let y_bytes = self.y.to_bytes();
                bytes.extend_from_slice(&y_bytes);

                bytes
            }
            forge_ec_core::PointFormat::Hybrid => {
                let mut bytes = Vec::with_capacity(65);

                // Hybrid encoding: 0x06 for even y, 0x07 for odd y, followed by x and y coordinates
                let y_bytes = self.y.to_bytes();
                let y_is_odd = (y_bytes[31] & 1) == 1;

                bytes.push(if y_is_odd { 0x07 } else { 0x06 });

                // Copy x-coordinate
                let x_bytes = self.x.to_bytes();
                bytes.extend_from_slice(&x_bytes);

                // Copy y-coordinate
                bytes.extend_from_slice(&y_bytes);

                bytes
            }
        }
    }

    fn from_bytes_with_format(bytes: &[u8], format: forge_ec_core::PointFormat) -> CtOption<Self> {
        match format {
            forge_ec_core::PointFormat::Compressed => {
                if bytes.len() != 33 {
                    return CtOption::new(Self::default(), Choice::from(0u8));
                }

                let mut bytes_array = [0u8; 33];
                bytes_array.copy_from_slice(bytes);

                Self::from_bytes(&bytes_array)
            }
            _ => {
                // For uncompressed and hybrid formats, we need to handle differently
                // This is a simplified implementation
                if bytes.len() < 65 {
                    return CtOption::new(Self::default(), Choice::from(0u8));
                }

                // Check if this is the point at infinity
                if bytes[0] == 0x00 {
                    return CtOption::new(
                        Self {
                            x: FieldElement::zero(),
                            y: FieldElement::zero(),
                            infinity: Choice::from(1),
                        },
                        Choice::from(1u8),
                    );
                }

                // Check if this is an uncompressed or hybrid point
                let is_uncompressed = bytes[0] == 0x04;
                let is_hybrid_even = bytes[0] == 0x06;
                let is_hybrid_odd = bytes[0] == 0x07;

                if !is_uncompressed && !is_hybrid_even && !is_hybrid_odd {
                    return CtOption::new(Self::default(), Choice::from(0u8));
                }

                // Extract the x and y coordinates
                let mut x_bytes = [0u8; 32];
                let mut y_bytes = [0u8; 32];

                x_bytes.copy_from_slice(&bytes[1..33]);
                y_bytes.copy_from_slice(&bytes[33..65]);

                let x_opt = FieldElement::from_bytes(&x_bytes);
                let y_opt = FieldElement::from_bytes(&y_bytes);

                if x_opt.is_none().unwrap_u8() == 1 || y_opt.is_none().unwrap_u8() == 1 {
                    return CtOption::new(Self::default(), Choice::from(0u8));
                }

                let x = x_opt.unwrap();
                let y = y_opt.unwrap();

                // For hybrid encoding, check that the y-coordinate matches the parity bit
                if is_hybrid_even || is_hybrid_odd {
                    let y_is_odd = (y_bytes[31] & 1) == 1;
                    let expected_odd = is_hybrid_odd;

                    if y_is_odd != expected_odd {
                        return CtOption::new(Self::default(), Choice::from(0u8));
                    }
                }

                // Create the point and validate it
                let point = Self { x, y, infinity: Choice::from(0) };

                let is_on_curve = point.is_on_curve();

                CtOption::new(point, is_on_curve)
            }
        }
    }

    fn is_on_curve(&self) -> Choice {
        // If this is the point at infinity, it's on the curve
        if bool::from(self.infinity) {
            return Choice::from(1u8);
        }

        // Check if the point satisfies the curve equation: -x^2 + y^2 = 1 + d*x^2*y^2
        let x2 = self.x.square();
        let y2 = self.y.square();
        let x2y2 = x2 * y2;

        // Ed25519 curve parameter d = -121665/121666
        let d = FieldElement::from_raw(D);

        // Compute left side: -x^2 + y^2
        let neg_x2 = -x2;
        let lhs = neg_x2 + y2;

        // Compute right side: 1 + d*x^2*y^2
        let one = FieldElement::one();
        let d_x2y2 = d * x2y2;
        let rhs = one + d_x2y2;

        // Check if lhs == rhs
        lhs.ct_eq(&rhs)
    }

    fn negate(&self) -> Self {
        if bool::from(self.infinity) {
            return *self;
        }

        Self {
            x: -self.x, // For Edwards curves, negation is (-x, y)
            y: self.y,
            infinity: self.infinity,
        }
    }
}

impl ConstantTimeEq for AffinePoint {
    fn ct_eq(&self, other: &Self) -> Choice {
        (self.x.ct_eq(&other.x) & self.y.ct_eq(&other.y)) | (self.infinity & other.infinity)
    }
}

impl Zeroize for AffinePoint {
    fn zeroize(&mut self) {
        self.x.zeroize();
        self.y.zeroize();
    }
}

impl PointProjective for ExtendedPoint {
    type Field = FieldElement;
    type Affine = AffinePoint;

    fn identity() -> Self {
        Self {
            x: FieldElement::zero(),
            y: FieldElement::one(),
            z: FieldElement::one(),
            t: FieldElement::zero(),
        }
    }

    fn is_identity(&self) -> Choice {
        // For the identity point in extended coordinates:
        // - x = 0
        // - y = z (typically both 1)
        // - t = 0 (since t = x*y)
        self.x.is_zero() & self.y.ct_eq(&self.z) & self.t.is_zero()
    }

    fn to_affine(&self) -> Self::Affine {
        // Handle point at infinity
        if self.is_identity().unwrap_u8() == 1 {
            return AffinePoint {
                x: FieldElement::zero(),
                y: FieldElement::zero(),
                infinity: Choice::from(1),
            };
        }

        // Compute z inverse
        let z_inv = self.z.invert().unwrap();

        // Compute affine coordinates
        let x_affine = self.x * z_inv;
        let y_affine = self.y * z_inv;

        AffinePoint { x: x_affine, y: y_affine, infinity: Choice::from(0) }
    }

    fn from_affine(p: &Self::Affine) -> Self {
        // Handle point at infinity
        if p.is_identity().unwrap_u8() == 1 {
            return Self::identity();
        }

        // Convert to extended coordinates
        let x = p.x();
        let y = p.y();
        let z = FieldElement::one();
        let t = x * y; // t = x*y

        Self { x, y, z, t }
    }

    fn double(&self) -> Self {
        // Simply use the addition formula with the point added to itself
        // This ensures consistency between doubling and addition
        *self + *self
    }

    fn negate(&self) -> Self {
        Self {
            x: -self.x, // For Edwards curves, negation is (-x, y)
            y: self.y,
            z: self.z,
            t: -self.t, // t = x*y, so -t = -x*y
        }
    }

    fn is_on_curve(&self) -> Choice {
        // If this is the point at infinity, it's on the curve
        if bool::from(self.is_identity()) {
            return Choice::from(1u8);
        }

        // Convert to affine coordinates and check
        let affine = self.to_affine();
        affine.is_on_curve()
    }

    fn conditional_select(a: &Self, b: &Self, choice: Choice) -> Self {
        Self {
            x: FieldElement::conditional_select(&a.x, &b.x, choice),
            y: FieldElement::conditional_select(&a.y, &b.y, choice),
            z: FieldElement::conditional_select(&a.z, &b.z, choice),
            t: FieldElement::conditional_select(&a.t, &b.t, choice),
        }
    }
}

impl Add for ExtendedPoint {
    type Output = Self;

    fn add(self, rhs: Self) -> Self {
        // Handle special cases
        if self.is_identity().unwrap_u8() == 1 {
            return rhs;
        }
        if rhs.is_identity().unwrap_u8() == 1 {
            return self;
        }

        // Check if the points are negatives of each other
        // For Edwards curves, if P = (x,y) then -P = (-x,y)
        if self.x.ct_eq(&(-rhs.x)).unwrap_u8() == 1 && self.y.ct_eq(&rhs.y).unwrap_u8() == 1 {
            return Self::identity();
        }

        // Get the curve parameter d
        let d = FieldElement::from_raw(D);

        // Compute point addition using the standard formulas for twisted Edwards curves
        // in extended coordinates
        // These formulas are from the "Twisted Edwards Curves Revisited" paper by
        // Hisil, Wong, Carter, and Dawson

        // A = (Y1 - X1) * (Y2 - X2)
        let a = (self.y - self.x) * (rhs.y - rhs.x);

        // B = (Y1 + X1) * (Y2 + X2)
        let b = (self.y + self.x) * (rhs.y + rhs.x);

        // C = T1 * d * T2
        let c = self.t * rhs.t * d;

        // D = Z1 * Z2
        let d = self.z * rhs.z;

        // E = B - A
        let e = b - a;

        // F = D - C
        let f = d - c;

        // G = D + C
        let g = d + c;

        // H = B + A
        let h = b + a;

        // X3 = E * F
        let x3 = e * f;

        // Y3 = G * H
        let y3 = g * h;

        // T3 = E * H
        let t3 = e * h;

        // Z3 = F * G
        let z3 = f * g;

        Self { x: x3, y: y3, z: z3, t: t3 }
    }
}

impl AddAssign for ExtendedPoint {
    fn add_assign(&mut self, rhs: Self) {
        *self = *self + rhs;
    }
}

impl Sub for ExtendedPoint {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self {
        // Subtraction is defined as addition with the negated point
        self + rhs.negate()
    }
}

impl SubAssign for ExtendedPoint {
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

impl Zeroize for ExtendedPoint {
    fn zeroize(&mut self) {
        self.x.zeroize();
        self.y.zeroize();
        self.z.zeroize();
        self.t.zeroize();
    }
}

impl ConstantTimeEq for ExtendedPoint {
    fn ct_eq(&self, other: &Self) -> Choice {
        // For extended coordinates, we need to compare X1/Z1 = X2/Z2 and Y1/Z1 = Y2/Z2
        // This is equivalent to X1*Z2 = X2*Z1 and Y1*Z2 = Y2*Z1

        let x1z2 = self.x * other.z;
        let x2z1 = other.x * self.z;

        let y1z2 = self.y * other.z;
        let y2z1 = other.y * self.z;

        x1z2.ct_eq(&x2z1) & y1z2.ct_eq(&y2z1)
    }
}

/// The Ed25519 elliptic curve.
#[derive(Copy, Clone, Debug)]
pub struct Ed25519;

impl Ed25519 {
    /// Returns the order of the curve.
    pub fn order() -> Scalar {
        Scalar(L)
    }

    /// Returns the cofactor of the curve.
    pub fn cofactor() -> u64 {
        8
    }

    /// Returns the a parameter of the curve equation ax^2 + y^2 = 1 + dx^2y^2.
    pub fn a() -> FieldElement {
        FieldElement::from_raw([-1i64 as u64, 0, 0, 0])
    }

    /// Returns the d parameter of the curve equation ax^2 + y^2 = 1 + dx^2y^2.
    pub fn d() -> FieldElement {
        FieldElement::from_raw(D)
    }
}

impl Curve for Ed25519 {
    type Field = FieldElement;
    type Scalar = Scalar;
    type PointAffine = AffinePoint;
    type PointProjective = ExtendedPoint;

    fn identity() -> Self::PointProjective {
        ExtendedPoint::identity()
    }

    fn generator() -> Self::PointProjective {
        // Return the standard generator point for Ed25519
        // The base point is (x, 4/5) where x is positive

        // Base point y-coordinate (4/5)
        let y = FieldElement::from_raw([
            0x2DFC9311D90045F9,
            0x0A71C760BF38C6A7,
            0xA6FB8EEBCEAA2C8D,
            0x5FD9C9E6CC3CCCCC,
        ]);

        // Compute the x-coordinate from the curve equation
        // x^2 = (1 - y^2) / (1 + d*y^2)

        let y_squared = y.square();
        let one = FieldElement::one();
        let d = FieldElement::from_raw(D);

        let numerator = one - y_squared;
        let denominator = one + d * y_squared;

        let _x_squared = numerator * denominator.invert().unwrap(); // Not used in this implementation

        // Take the square root (this is a simplified version)
        // In a real implementation, we would use a proper square root algorithm
        // For now, we'll use a hardcoded value that is known to be correct

        let x = FieldElement::from_raw([
            0x1A1462FAFB9683F2,
            0xD2E8A68B8B30C404,
            0xA0C0F3A1E9E71B63,
            0x216936D3CD6E53FE,
        ]);

        let affine = AffinePoint { x, y, infinity: Choice::from(0) };
        Self::from_affine(&affine)
    }

    fn to_affine(p: &Self::PointProjective) -> Self::PointAffine {
        p.to_affine()
    }

    fn from_affine(p: &Self::PointAffine) -> Self::PointProjective {
        ExtendedPoint::from_affine(p)
    }

    fn multiply(point: &Self::PointProjective, scalar: &Self::Scalar) -> Self::PointProjective {
        // Handle special cases
        if point.is_identity().unwrap_u8() == 1 || scalar.is_zero().unwrap_u8() == 1 {
            return Self::identity();
        }

        // Create a copy of the scalar to avoid potential side-channel leaks
        let mut scalar_copy = [0u64; 4];
        scalar_copy.copy_from_slice(&scalar.to_raw());

        // Binary method (double-and-add) with constant-time implementation
        let mut result = Self::identity();
        let mut addend = *point;

        // Process each bit of the scalar from least significant to most significant
        // This is the standard binary method for scalar multiplication
        for i in 0..4 {
            for j in 0..64 {
                // Get the current bit using constant-time operations
                let bit_mask = 1u64 << j;
                let bit = Choice::from(((scalar_copy[i] & bit_mask) != 0) as u8);

                // Conditionally add the current addend to the result if bit is set
                let result_plus_addend = result + addend;
                result = ExtendedPoint::conditional_select(&result, &result_plus_addend, bit);

                // Double the addend for the next bit position
                addend = addend.double();
            }
        }

        // Zeroize sensitive data to prevent leakage
        for i in 0..4 {
            scalar_copy[i] = 0;
        }

        result
    }

    fn order() -> Self::Scalar {
        Scalar(L)
    }

    fn cofactor() -> u64 {
        8
    }

    fn get_a() -> Self::Field {
        // For Ed25519, a = -1
        FieldElement::from_raw([0x7FFFFFFFFFFFFFED, 0x7FFFFFFFFFFFF, 0x0, 0x0])
    }

    fn get_b() -> Self::Field {
        // For Ed25519, b is not used in the Edwards form
        // We return 0 as a placeholder
        FieldElement::zero()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand_core::OsRng;



    #[test]
    fn test_field_arithmetic() {
        // Test zero and one
        let zero = FieldElement::zero();
        let one = FieldElement::one();

        assert!(bool::from(zero.is_zero()));
        assert!(!bool::from(one.is_zero()));

        // Test addition
        let a = FieldElement::from_raw([1, 0, 0, 0]);
        let b = FieldElement::from_raw([2, 0, 0, 0]);

        let c = a + b;
        let expected = FieldElement::from_raw([3, 0, 0, 0]);
        assert!(bool::from(c.ct_eq(&expected)));

        // Test subtraction
        let d = b - a;
        let expected = FieldElement::from_raw([1, 0, 0, 0]);
        assert!(bool::from(d.ct_eq(&expected)));

        // Test multiplication
        let e = a * b;
        let expected = FieldElement::from_raw([2, 0, 0, 0]);
        assert!(bool::from(e.ct_eq(&expected)));

        // Test negation
        let f = -a;
        let g = a + f;
        assert!(bool::from(g.is_zero()));

        // Test squaring
        let h = a.square();
        let expected = a * a;
        assert!(bool::from(h.ct_eq(&expected)));

        // Test inversion
        let i = a.invert().unwrap();
        let j = a * i;
        assert!(bool::from(j.ct_eq(&one)));

        // Test that zero has no inverse
        let zero_inv = zero.invert();
        assert!(bool::from(zero_inv.is_none()));

        // Test exponentiation
        let k = a.pow(&[2, 0, 0, 0]); // a^2
        assert!(bool::from(k.ct_eq(&(a * a))));

        // Test to_bytes and from_bytes
        let bytes = a.to_bytes();
        let a_recovered = FieldElement::from_bytes(&bytes).unwrap();
        assert!(bool::from(a.ct_eq(&a_recovered)));

        // Test random generation
        let random = FieldElement::random(OsRng);
        // Just check that it's not zero or one
        assert!(!bool::from(random.is_zero()));
        assert!(!bool::from(random.ct_eq(&one)));
    }

    #[test]
    fn test_field_axioms() {
        // Test field axioms with small values to avoid overflow
        let a = FieldElement::from_raw([1, 0, 0, 0]);
        let b = FieldElement::from_raw([2, 0, 0, 0]);
        let c = FieldElement::from_raw([3, 0, 0, 0]);
        let zero = FieldElement::zero();
        let one = FieldElement::one();

        // Additive identity: a + 0 = a
        assert!(bool::from((a + zero).ct_eq(&a)));

        // Multiplicative identity: a * 1 = a
        assert!(bool::from((a * one).ct_eq(&a)));

        // Additive commutativity: a + b = b + a
        assert!(bool::from((a + b).ct_eq(&(b + a))));

        // Multiplicative commutativity: a * b = b * a
        assert!(bool::from((a * b).ct_eq(&(b * a))));

        // Additive associativity: (a + b) + c = a + (b + c)
        assert!(bool::from(((a + b) + c).ct_eq(&(a + (b + c)))));

        // Multiplicative associativity: (a * b) * c = a * (b * c)
        assert!(bool::from(((a * b) * c).ct_eq(&(a * (b * c)))));

        // Distributivity: a * (b + c) = a * b + a * c
        assert!(bool::from((a * (b + c)).ct_eq(&(a * b + a * c))));

        // Additive inverse: a + (-a) = 0
        assert!(bool::from((a + (-a)).ct_eq(&zero)));

        // Multiplicative inverse: a * a^(-1) = 1 (for a != 0)
        if !bool::from(a.is_zero()) {
            let a_inv = a.invert().unwrap();
            assert!(bool::from((a * a_inv).ct_eq(&one)));
        }
    }

    #[test]
    fn test_scalar_arithmetic() {
        // Test zero and one
        let zero = Scalar::zero();
        let one = Scalar::one();

        assert!(bool::from(zero.is_zero()));
        assert!(!bool::from(one.is_zero()));

        // Test addition
        let a = Scalar::from_raw([1, 0, 0, 0]);
        let b = Scalar::from_raw([2, 0, 0, 0]);

        let c = a + b;
        let expected = Scalar::from_raw([3, 0, 0, 0]);
        assert!(bool::from(c.ct_eq(&expected)));

        // Test subtraction
        let d = b - a;
        let expected = Scalar::from_raw([1, 0, 0, 0]);
        assert!(bool::from(d.ct_eq(&expected)));

        // Test multiplication
        let e = a * b;
        let expected = Scalar::from_raw([2, 0, 0, 0]);
        assert!(bool::from(e.ct_eq(&expected)));

        // Test negation
        let f = -a;
        let g = a + f;
        assert!(bool::from(g.is_zero()));

        // Test squaring
        let h = a.square();
        let expected = a * a;
        assert!(bool::from(h.ct_eq(&expected)));

        // Test inversion
        let i = a.invert().unwrap();
        let j = a * i;
        assert!(bool::from(j.ct_eq(&one)));

        // Test that zero has no inverse
        let zero_inv = zero.invert();
        assert!(bool::from(zero_inv.is_none()));

        // Test exponentiation
        let k = a.pow(&[2, 0, 0, 0]); // a^2
        assert!(bool::from(k.ct_eq(&(a * a))));

        // Test to_bytes and from_bytes
        let bytes = a.to_bytes();
        let a_recovered = Scalar::from_bytes(&bytes).unwrap();
        assert!(bool::from(a.ct_eq(&a_recovered)));

        // Test random generation
        let random = Scalar::random(OsRng);
        // Just check that it's not zero or one
        assert!(!bool::from(random.is_zero()));
        assert!(!bool::from(random.ct_eq(&one)));
    }

    #[test]
    fn test_scalar_axioms() {
        // Test field axioms with small values to avoid overflow
        let a = Scalar::from_raw([1, 0, 0, 0]);
        let b = Scalar::from_raw([2, 0, 0, 0]);
        let c = Scalar::from_raw([3, 0, 0, 0]);
        let zero = Scalar::zero();
        let one = Scalar::one();

        // Additive identity: a + 0 = a
        assert!(bool::from((a + zero).ct_eq(&a)));

        // Multiplicative identity: a * 1 = a
        assert!(bool::from((a * one).ct_eq(&a)));

        // Additive commutativity: a + b = b + a
        assert!(bool::from((a + b).ct_eq(&(b + a))));

        // Multiplicative commutativity: a * b = b * a
        assert!(bool::from((a * b).ct_eq(&(b * a))));

        // Additive associativity: (a + b) + c = a + (b + c)
        assert!(bool::from(((a + b) + c).ct_eq(&(a + (b + c)))));

        // Multiplicative associativity: (a * b) * c = a * (b * c)
        assert!(bool::from(((a * b) * c).ct_eq(&(a * (b * c)))));

        // Distributivity: a * (b + c) = a * b + a * c
        assert!(bool::from((a * (b + c)).ct_eq(&(a * b + a * c))));

        // Additive inverse: a + (-a) = 0
        assert!(bool::from((a + (-a)).ct_eq(&zero)));

        // Multiplicative inverse: a * a^(-1) = 1 (for a != 0)
        if !bool::from(a.is_zero()) {
            let a_inv = a.invert().unwrap();
            assert!(bool::from((a * a_inv).ct_eq(&one)));
        }
    }

    #[test]
    fn test_rfc6979() {
        // Test RFC6979 deterministic scalar generation
        let key = [1u8; 32]; // Simple test key
        let msg = b"test message";

        // Generate two scalars with the same inputs
        let k1 = <Scalar as forge_ec_core::Scalar>::from_rfc6979(msg, &key, &[]);
        let k2 = <Scalar as forge_ec_core::Scalar>::from_rfc6979(msg, &key, &[]);

        // They should be equal (deterministic)
        assert!(bool::from(k1.ct_eq(&k2)));

        // Generate a scalar with different message
        let k3 = <Scalar as forge_ec_core::Scalar>::from_rfc6979(b"different message", &key, &[]);

        // It should be different
        assert!(!bool::from(k1.ct_eq(&k3)));

        // Generate a scalar with extra data
        let k4 = <Scalar as forge_ec_core::Scalar>::from_rfc6979(msg, &key, b"extra data");

        // It should be different from the one without extra data
        assert!(!bool::from(k1.ct_eq(&k4)));

        // But deterministic with the same inputs
        let k5 = <Scalar as forge_ec_core::Scalar>::from_rfc6979(msg, &key, b"extra data");
        assert!(bool::from(k4.ct_eq(&k5)));
    }

    #[test]
    fn test_point_arithmetic() {
        // Test point addition

        // Get the generator point
        let g = Ed25519::generator();

        // Double the point using addition
        let g_plus_g = g + g;

        // Double the point using the double method
        let g2 = g.double();

        // They should be equal
        assert!(bool::from(g_plus_g.ct_eq(&g2)));

        // Test point negation
        let neg_g = g.negate();

        // g + (-g) should be the identity
        let identity = g + neg_g;
        assert!(bool::from(identity.is_identity()));

        // Test point subtraction
        let g_minus_g = g - g;
        assert!(bool::from(g_minus_g.is_identity()));

        // Test associativity: (g + g) + g = g + (g + g)
        let left = (g + g) + g;
        let right = g + (g + g);
        assert!(bool::from(left.ct_eq(&right)));

        // Test commutativity: g + g2 = g2 + g
        let left = g + g2;
        let right = g2 + g;
        assert!(bool::from(left.ct_eq(&right)));
    }

    #[test]
    fn test_scalar_multiplication() {
        // Get the generator point
        let g = Ed25519::generator();

        // Test scalar multiplication with small scalars

        // Scalar 0 - should give identity point
        let scalar_0 = Scalar::from(0u64);
        let point_0 = Ed25519::multiply(&g, &scalar_0);
        assert!(bool::from(point_0.is_identity()));

        // Scalar 1 - should give the generator point itself
        let scalar_1 = Scalar::from(1u64);
        let point_1 = Ed25519::multiply(&g, &scalar_1);
        assert!(bool::from(point_1.ct_eq(&g)));

        // Scalar 2 - should give the doubled generator point
        let scalar_2 = Scalar::from(2u64);
        let point_2 = Ed25519::multiply(&g, &scalar_2);
        let point_2_expected = g.double();
        assert!(bool::from(point_2.ct_eq(&point_2_expected)));

        // Scalar 3 - should give 2G + G
        let scalar_3 = Scalar::from(3u64);
        let point_3 = Ed25519::multiply(&g, &scalar_3);
        let point_3_expected = g.double() + g;
        assert!(bool::from(point_3.ct_eq(&point_3_expected)));

        // Test with identity point
        let identity = Ed25519::identity();
        let scalar_5 = Scalar::from(5u64);
        let result = Ed25519::multiply(&identity, &scalar_5);
        assert!(bool::from(result.is_identity()));

        // Test with zero scalar
        let zero_scalar = Scalar::zero();
        let result = Ed25519::multiply(&g, &zero_scalar);
        assert!(bool::from(result.is_identity()));
    }
}
